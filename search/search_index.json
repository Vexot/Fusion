{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"const header = document.querySelector(\"[data-md-color-primary=black] .md-header\") function updateScroll() { if(document.body.scrollTop > 10) { header.dataset.mdState = \"shadow\"; } else { header.dataset.mdState = \"\"; } } updateScroll(); document.body.addEventListener(\"scroll\", updateScroll); Construye tu mejor UI. Fusion es una biblioteca reactiva moderna, construida espec\u00edficamente para Roblox y Luau . Construye tu UI con una sintaxis declarativa que es f\u00e1cil de leer y escribir. Conecta datos en vivo con una gesti\u00f3n de estados realmente simple, flexible y reactiva. Entrega una experiencia impecable y r\u00e1pida a todos - en m\u00f3vil, consola, PC o VR. Empezar Descargar \u00faltimo lanzamiento Sintaxis declarativa de UI Fusion provee una sintaxis natural y f\u00e1cil de leer, para que te puedas enfocar en c\u00f3mo tu UI debe verse, sin preocuparte acerca de su implementaci\u00f3n. Enf\u00f3cate en las propiedades y los children en tu UI, no en APIs verbosos. return New \"ScreenGui\" { Parent = Players . LocalPlayer . PlayerGui , [ Children ] = New \"TextButton\" { Position = UDim2 . fromScale ( .5 , .5 ) AnchorPoint = Vector2 . new ( .5 , .5 ), Size = UDim2 . fromOffset ( 200 , 50 ), Text = \"Fusion es divertido :)\" , [ OnEvent \"Activated\" ] = function () print ( \"\u00a1Cliqueado!\" ) end } } Gesti\u00f3n de estados reactivos Escribe fluidamente todos tus c\u00e1lculos, y se ejecutar\u00e1n autom\u00e1ticamente cuando sus variables cambian. Fusion acelera y optimiza todos tus c\u00e1lculos por ti. local numCoins = State ( 10 ) local doubleCoins = Computed ( function () return numCoins : get () * 2 end ) local coinsMessage = Computed ( function () return \"Tienes \" .. numCoins : get () .. \" monedas.\" end ) return New \"TextLabel\" { Text = coinsMessage } Anima todo Dale vida a tu UI con las herramientas de animaci\u00f3n m\u00e1s f\u00e1ciles y universales de cualquier biblioteca de Roblox. Accede a tweens y springs con una l\u00ednea de c\u00f3digo. Anima cualquier cosa instant\u00e1neamente, sin necesidad de usar refactorizaci\u00f3n o trucos de rendimiento. local playerCount = State ( 100 ) local position = State ( UDim2 . new ( 0 , 0 , 0 , 0 )) local smoothCount = Tween ( playerCount , TweenInfo . new ( 0.5 )) return New \"TextLabel\" { Position = Spring ( position , 25 , 0.2 ), Text = Computed ( function () return \"Jugadores en l\u00ednea: \" .. math.floor ( smoothCount : get ()) end ) } Fusion es construido teniendo en cuenta el rendimiento, desde la idea hasta la implementaci\u00f3n. Desde PCs de escritorio de gama alta hasta celulares de hace a\u00f1os, Fusion entrega una experiencia excepcionalmente impecable y ligera como est\u00e1ndar. Construye tus interfaces m\u00e1s bonitas, intr\u00e9pidas y animadas con confianza - Fusion se adapta a dispositivos con alta frecuencia de actualizaci\u00f3n y VR. Ponte en marcha con Fusion en minutos. Descargar e importar Fusion a Studio es r\u00e1pido, f\u00e1cil y 100% gratis. Los tutoriales para comenzar est\u00e1n dirigidos a una amplia gama de creadores, desde desarrolladores de UI expertos a programadores novatos.","title":"Inicio"},{"location":"api-reference/","text":"Referencia del API \u00b6 Fusion es una biblioteca reactiva moderna, construida para Roblox y Luau . Aqu\u00ed, puedes encontrar documentaci\u00f3n para cada API p\u00fablica expuesta por el m\u00f3dulo de Fusion. Navegaci\u00f3n \u00b6 Usando la barra lateral de la izquierda, puedes encontrar miembros de la API agrupados por categor\u00eda. Como alternativa puedes buscar las APIs usando la barra de b\u00fasqueda en la parte superior de la p\u00e1gina. Informaci\u00f3n de Tipos \u00b6 En varias p\u00e1ginas de la API, ver\u00e1s anotaciones de tipos describiendo el miembro de la API. Por ejemplo: function New ( className : string ): ( props : {[ string | Symbol ]: any }) -> Instance Mientras que este tipo de anotaciones son dise\u00f1adas para ser como las de Luau, estas son b\u00e1sicamente pseudoc\u00f3digos incluidos para ayudar al desarrollador. Para una total precisi\u00f3n y sintaxis, por favor consulta el c\u00f3digo fuente directamente. Usadas Com\u00fanmente \u00b6 Dir\u00edgete directamente a la documentaci\u00f3n para ver algunas APIs comunes: Instancias \u00b6 New Gesti\u00f3n de State \u00b6 State Computed ComputedPairs Animaci\u00f3n \u00b6 Tween Spring \u00daltima Actualizaci\u00f3n de la Localizaci\u00f3n 10/10/2021","title":"Inicio"},{"location":"api-reference/#referencia-del-api","text":"Fusion es una biblioteca reactiva moderna, construida para Roblox y Luau . Aqu\u00ed, puedes encontrar documentaci\u00f3n para cada API p\u00fablica expuesta por el m\u00f3dulo de Fusion.","title":"Referencia del API"},{"location":"api-reference/#navegacion","text":"Usando la barra lateral de la izquierda, puedes encontrar miembros de la API agrupados por categor\u00eda. Como alternativa puedes buscar las APIs usando la barra de b\u00fasqueda en la parte superior de la p\u00e1gina.","title":"Navegaci\u00f3n"},{"location":"api-reference/#informacion-de-tipos","text":"En varias p\u00e1ginas de la API, ver\u00e1s anotaciones de tipos describiendo el miembro de la API. Por ejemplo: function New ( className : string ): ( props : {[ string | Symbol ]: any }) -> Instance Mientras que este tipo de anotaciones son dise\u00f1adas para ser como las de Luau, estas son b\u00e1sicamente pseudoc\u00f3digos incluidos para ayudar al desarrollador. Para una total precisi\u00f3n y sintaxis, por favor consulta el c\u00f3digo fuente directamente.","title":"Informaci\u00f3n de Tipos"},{"location":"api-reference/#usadas-comunmente","text":"Dir\u00edgete directamente a la documentaci\u00f3n para ver algunas APIs comunes:","title":"Usadas Com\u00fanmente"},{"location":"api-reference/#instancias","text":"New","title":"Instancias"},{"location":"api-reference/#gestion-de-state","text":"State Computed ComputedPairs","title":"Gesti\u00f3n de State"},{"location":"api-reference/#animacion","text":"Tween Spring \u00daltima Actualizaci\u00f3n de la Localizaci\u00f3n 10/10/2021","title":"Animaci\u00f3n"},{"location":"api-reference/errors-and-messages/","text":"Si tu c\u00f3digo no est\u00e1 funcionando adecuadamente o si Fusion est\u00e1 fallando, podr\u00edas ver algunos errores aparecer en el output. Cada mensaje tiene un ID \u00fanico al final. En esta p\u00e1gina, puedes aprender m\u00e1s acerca de cualquier error que est\u00e9s recibiendo. cannotAssignProperty \u00b6 The class type 'Foo' has no assignable property 'Bar'. Este mensaje aparece si est\u00e1s intentando asignar una propiedad no existente o bloqueada usando la funci\u00f3n New : local folder = New \"Folder\" { DataCost = 12345 , ThisPropertyDoesntExist = \"Ejemplo\" } Tip Diferentes scripts pueden tener diferentes privilegios - por ejemplo, los plugins tienen un mayor privilegio que los scripts del juego. \u00a1Aseg\u00farate de tener los privilegios necesarios para poder asignar a tus propiedades! cannotConnectChange \u00b6 The Frame class doesn't have a property called 'Foo'. Este mensaje aparece si est\u00e1s intentando conectar un handler con una propiedad de change event que no existe usando la funci\u00f3n New : local textBox = New \"TextBox\" { [ OnChange \"EstaPropiedadNoExiste\" ] = function () ... end ) } cannotConnectEvent \u00b6 The Frame class doesn't have an event called 'Foo'. Este mensaje aparece si est\u00e1s intentando conectar un handler con un evento que no existe usando la funci\u00f3n New : local button = New \"TextButton\" { [ OnEvent \"EsteEventoNoExiste\" ] = function () ... end ) } cannotCreateClass \u00b6 Can't create a new instance of class 'Foo'. Este mensaje aparece cuando se usa la funci\u00f3n New con una clase de tipo inv\u00e1lida: local instance = New \"ThisClassTypeIsInvalid\" { ... } computedCallbackError \u00b6 Computed callback error: attempt to index a nil value Este mensaje aparece cuando el callback de un computed object encuentra un error: local example = Computed ( function () local badMath = 2 + \"pez\" end ) invalidSpringDamping \u00b6 The damping ratio for a spring must be >= 0. (damping was -0.50) Este mensaje aparece si est\u00e1s intentando proporcionar una amortiguaci\u00f3n a un spring que sea menor que 0: local speed = 10 local damping = - 12345 local spring = Spring ( state , speed , damping ) La amortiguaci\u00f3n siempre tiene que ser entre 0 y infinito para que un spring sea f\u00edsicamente simulable. invalidSpringSpeed \u00b6 The speed of a spring must be >= 0. (speed was -2.00) Este mensaje aparece si est\u00e1s intentando proporcionar una velocidad a un spring que sea menor que 0: local speed = - 12345 local spring = Spring ( state , speed ) Ya que una velocidad de 0 es equivalente a un spring que no se mueve, cualquier velocidad menor no es simulable o f\u00edsicamente sensible. mistypedSpringDamping \u00b6 The damping ratio for a spring must be a number. (got a boolean) Este mensaje aparece si est\u00e1s intentando proporcionar una amortiguaci\u00f3n a un spring que no sea un n\u00famero: local speed = 10 local damping = true local spring = Spring ( state , speed , damping ) mistypedSpringSpeed \u00b6 The speed of a spring must be a number. (got a boolean) Este mensaje aparece si est\u00e1s intentando proporcionar una velocidad a un spring que no sea un n\u00famero: local speed = true local spring = Spring ( state , speed ) pairsDestructorError \u00b6 ComputedPairs destructor error: attempt to index a nil value Este mensaje aparece cuando el callback destructor de un ComputedPairs object encuentra un error: local example = ComputedPairs ( data , processor , function ( value ) local badMath = 2 + \"pez\" end ) pairsProcessorError \u00b6 ComputedPairs callback error: attempt to index a nil value Este mensaje aparece cuando el callback processor de un ComputedPairs object encuentra un error: local example = ComputedPairs ( data , function ( key , value ) local badMath = 2 + \"pez\" end ) springTypeMismatch \u00b6 The type 'number' doesn't match the spring's type 'Color3'. Algunos m\u00e9todos en objetos de spring requieren valores entrantes para emparejar los tipos que fueron usados previamente en el spring. Este mensaje aparece cuando un valor entrante no tiene el mismo tipo que los valores usados previamente en el spring: local colour = State ( Color3 . new ( 1 , 0 , 0 )) local colourSpring = Spring ( colour ) colourSpring : addVelocity ( Vector2 . new ( 2 , 3 )) strictReadError \u00b6 'Foo' is not a valid member of 'Bar'. En Fusion, algunas tablas pueden tener reglas de lectura estrictas (strict). Esto es com\u00fanmente usado en APIs p\u00fablicas como defensa de errores de escritura. Este mensaje aparece cuando se intenta leer un miembro no existente de estas tablas. unknownMessage \u00b6 Unknown error: attempt to index a nil value Si ves este mensaje, es casi seguro que sea un bug interno, as\u00ed que aseg\u00farate de ponerte en contacto para que el error pueda ser arreglado. Cuando el c\u00f3digo de Fusion intenta registrar un mensaje, advertencia o error, necesita proporcionar un ID. Este ID es usado para mostrar el mensaje correcto, y funciona como un identificador simple y memorable por si necesitas buscar el mensaje despu\u00e9s. Sin embargo, si ese c\u00f3digo no proporciona un ID v\u00e1lido, entonces el mensaje ser\u00e1 reemplazado con este. unrecognisedChildType \u00b6 'number' type children aren't accepted as children in `New`. Este mensaje aparece cuando se intenta pasar algo como un child que no es una instancia, tabla de instancias, o state object que contenga una instancia (cuando se usa la funci\u00f3n New ): local instance = New \"Folder\" { [ Children ] = { 1 , 2 , 3 , 4 , 5 , { true , false }, State ( Enum . Material . Grass ) } } Note Ten en cuenta que los state objects pueden guardar nil para representar la ausencia de una instancia, como excepci\u00f3n a estas reglas. unrecognisedPropertyKey \u00b6 'number' keys aren't accepted in the property table of `New`. Cuando creas una instancia en Fusion usando New , puedes pasar una 'property table' que contenga propiedades, children, handlers de cambio de propiedad y eventos, etc. Esta tabla solo se espera que contenga keys de dos tipos: string keys, ej. Name = \"Ejemplo\" unas cuantas keys de s\u00edmbolos, ej. [ OnEvent \"Foo\" ] = ... Este mensaje aparece si Fusion encuentra una key de un tipo diferente, o si la key no es una de las keys de s\u00edmbolos usadas en New: local folder = New \"Folder\" { [ Vector3 . new ()] = \"Ejemplo\" , \"Esto\" , \"No deberia\" , \"Estar\" , \"Aqu\u00ed\" } \u00daltima Actualizaci\u00f3n de la Localizaci\u00f3n 10/10/2021","title":"Errores y Mensajes"},{"location":"api-reference/errors-and-messages/#cannotassignproperty","text":"The class type 'Foo' has no assignable property 'Bar'. Este mensaje aparece si est\u00e1s intentando asignar una propiedad no existente o bloqueada usando la funci\u00f3n New : local folder = New \"Folder\" { DataCost = 12345 , ThisPropertyDoesntExist = \"Ejemplo\" } Tip Diferentes scripts pueden tener diferentes privilegios - por ejemplo, los plugins tienen un mayor privilegio que los scripts del juego. \u00a1Aseg\u00farate de tener los privilegios necesarios para poder asignar a tus propiedades!","title":"cannotAssignProperty"},{"location":"api-reference/errors-and-messages/#cannotconnectchange","text":"The Frame class doesn't have a property called 'Foo'. Este mensaje aparece si est\u00e1s intentando conectar un handler con una propiedad de change event que no existe usando la funci\u00f3n New : local textBox = New \"TextBox\" { [ OnChange \"EstaPropiedadNoExiste\" ] = function () ... end ) }","title":"cannotConnectChange"},{"location":"api-reference/errors-and-messages/#cannotconnectevent","text":"The Frame class doesn't have an event called 'Foo'. Este mensaje aparece si est\u00e1s intentando conectar un handler con un evento que no existe usando la funci\u00f3n New : local button = New \"TextButton\" { [ OnEvent \"EsteEventoNoExiste\" ] = function () ... end ) }","title":"cannotConnectEvent"},{"location":"api-reference/errors-and-messages/#cannotcreateclass","text":"Can't create a new instance of class 'Foo'. Este mensaje aparece cuando se usa la funci\u00f3n New con una clase de tipo inv\u00e1lida: local instance = New \"ThisClassTypeIsInvalid\" { ... }","title":"cannotCreateClass"},{"location":"api-reference/errors-and-messages/#computedcallbackerror","text":"Computed callback error: attempt to index a nil value Este mensaje aparece cuando el callback de un computed object encuentra un error: local example = Computed ( function () local badMath = 2 + \"pez\" end )","title":"computedCallbackError"},{"location":"api-reference/errors-and-messages/#invalidspringdamping","text":"The damping ratio for a spring must be >= 0. (damping was -0.50) Este mensaje aparece si est\u00e1s intentando proporcionar una amortiguaci\u00f3n a un spring que sea menor que 0: local speed = 10 local damping = - 12345 local spring = Spring ( state , speed , damping ) La amortiguaci\u00f3n siempre tiene que ser entre 0 y infinito para que un spring sea f\u00edsicamente simulable.","title":"invalidSpringDamping"},{"location":"api-reference/errors-and-messages/#invalidspringspeed","text":"The speed of a spring must be >= 0. (speed was -2.00) Este mensaje aparece si est\u00e1s intentando proporcionar una velocidad a un spring que sea menor que 0: local speed = - 12345 local spring = Spring ( state , speed ) Ya que una velocidad de 0 es equivalente a un spring que no se mueve, cualquier velocidad menor no es simulable o f\u00edsicamente sensible.","title":"invalidSpringSpeed"},{"location":"api-reference/errors-and-messages/#mistypedspringdamping","text":"The damping ratio for a spring must be a number. (got a boolean) Este mensaje aparece si est\u00e1s intentando proporcionar una amortiguaci\u00f3n a un spring que no sea un n\u00famero: local speed = 10 local damping = true local spring = Spring ( state , speed , damping )","title":"mistypedSpringDamping"},{"location":"api-reference/errors-and-messages/#mistypedspringspeed","text":"The speed of a spring must be a number. (got a boolean) Este mensaje aparece si est\u00e1s intentando proporcionar una velocidad a un spring que no sea un n\u00famero: local speed = true local spring = Spring ( state , speed )","title":"mistypedSpringSpeed"},{"location":"api-reference/errors-and-messages/#pairsdestructorerror","text":"ComputedPairs destructor error: attempt to index a nil value Este mensaje aparece cuando el callback destructor de un ComputedPairs object encuentra un error: local example = ComputedPairs ( data , processor , function ( value ) local badMath = 2 + \"pez\" end )","title":"pairsDestructorError"},{"location":"api-reference/errors-and-messages/#pairsprocessorerror","text":"ComputedPairs callback error: attempt to index a nil value Este mensaje aparece cuando el callback processor de un ComputedPairs object encuentra un error: local example = ComputedPairs ( data , function ( key , value ) local badMath = 2 + \"pez\" end )","title":"pairsProcessorError"},{"location":"api-reference/errors-and-messages/#springtypemismatch","text":"The type 'number' doesn't match the spring's type 'Color3'. Algunos m\u00e9todos en objetos de spring requieren valores entrantes para emparejar los tipos que fueron usados previamente en el spring. Este mensaje aparece cuando un valor entrante no tiene el mismo tipo que los valores usados previamente en el spring: local colour = State ( Color3 . new ( 1 , 0 , 0 )) local colourSpring = Spring ( colour ) colourSpring : addVelocity ( Vector2 . new ( 2 , 3 ))","title":"springTypeMismatch"},{"location":"api-reference/errors-and-messages/#strictreaderror","text":"'Foo' is not a valid member of 'Bar'. En Fusion, algunas tablas pueden tener reglas de lectura estrictas (strict). Esto es com\u00fanmente usado en APIs p\u00fablicas como defensa de errores de escritura. Este mensaje aparece cuando se intenta leer un miembro no existente de estas tablas.","title":"strictReadError"},{"location":"api-reference/errors-and-messages/#unknownmessage","text":"Unknown error: attempt to index a nil value Si ves este mensaje, es casi seguro que sea un bug interno, as\u00ed que aseg\u00farate de ponerte en contacto para que el error pueda ser arreglado. Cuando el c\u00f3digo de Fusion intenta registrar un mensaje, advertencia o error, necesita proporcionar un ID. Este ID es usado para mostrar el mensaje correcto, y funciona como un identificador simple y memorable por si necesitas buscar el mensaje despu\u00e9s. Sin embargo, si ese c\u00f3digo no proporciona un ID v\u00e1lido, entonces el mensaje ser\u00e1 reemplazado con este.","title":"unknownMessage"},{"location":"api-reference/errors-and-messages/#unrecognisedchildtype","text":"'number' type children aren't accepted as children in `New`. Este mensaje aparece cuando se intenta pasar algo como un child que no es una instancia, tabla de instancias, o state object que contenga una instancia (cuando se usa la funci\u00f3n New ): local instance = New \"Folder\" { [ Children ] = { 1 , 2 , 3 , 4 , 5 , { true , false }, State ( Enum . Material . Grass ) } } Note Ten en cuenta que los state objects pueden guardar nil para representar la ausencia de una instancia, como excepci\u00f3n a estas reglas.","title":"unrecognisedChildType"},{"location":"api-reference/errors-and-messages/#unrecognisedpropertykey","text":"'number' keys aren't accepted in the property table of `New`. Cuando creas una instancia en Fusion usando New , puedes pasar una 'property table' que contenga propiedades, children, handlers de cambio de propiedad y eventos, etc. Esta tabla solo se espera que contenga keys de dos tipos: string keys, ej. Name = \"Ejemplo\" unas cuantas keys de s\u00edmbolos, ej. [ OnEvent \"Foo\" ] = ... Este mensaje aparece si Fusion encuentra una key de un tipo diferente, o si la key no es una de las keys de s\u00edmbolos usadas en New: local folder = New \"Folder\" { [ Vector3 . new ()] = \"Ejemplo\" , \"Esto\" , \"No deberia\" , \"Estar\" , \"Aqu\u00ed\" } \u00daltima Actualizaci\u00f3n de la Localizaci\u00f3n 10/10/2021","title":"unrecognisedPropertyKey"},{"location":"api-reference/api/children/","text":"local Children : Symbol El s\u00edmbolo utilizado para denotar los children de una instancia cuando se trabaja con la funci\u00f3n New . Cuando se usa este s\u00edmbolo como key en la tabla de propiedades de New , los valores ser\u00e1n tratados como children, y su parent ser\u00e1 establecido de acuerdo a las reglas posteriores. Ejemplo de Uso \u00b6 local example = New \"Folder\" { [ Children ] = New \"StringValue\" { Value = \"\u00a1Mi parent es la Folder!\" } } Procesando Children \u00b6 Un 'child' es definido (recursivamente) como: una instancia un state object o computed object que contenga children una array de children Dado que esta definici\u00f3n es recursiva, arrays y state objects pueden ser anidadas; es decir que el siguiente c\u00f3digo es v\u00e1lido: local example = New \"Folder\" { [ Children ] = { { { New \"StringValue\" { Value = \"\u00a1Mi parent es la Folder!\" } } } } } Este comportamiento es especialmente \u00fatil al trabajar con componentes - el siguiente componente puede regresar m\u00faltiples instancias para establecer sus parents sin interrumpir el c\u00f3digo junto a \u00e9l: local function Component ( props ) return { New \"TextLabel\" { LayoutOrder = 1 , Text = \"Instancia uno\" }, New \"TextLabel\" { LayoutOrder = 2 , Text = \"Instancia dos\" } } end local parent = New \"Frame\" { Children = { New \"UIListLayout\" { SortOrder = \"LayoutOrder\" }, Component {} } } Al usar state o computed object como child, se vincular\u00e1; cuando el valor del state object cambia, se le quitara el parent a los viejos children y se le establecer\u00e1 el parent a los nuevos children. Note Al igual que con propiedades bound, las actualizaciones son pospuestas al siguiente render step, por lo que el establecimiento de un parent no ocurrir\u00e1 al instante. local child1 = New \"Folder\" { Name = \"Child uno\" } local child2 = New \"Folder\" { Name = \"Child dos\" } local childState = State ( child1 ) local parent = New \"Folder\" { [ Children ] = childState } print ( parent : GetChildren ()) -- { Child uno } childState : set ( child2 ) wait ( 1 ) -- espera a que las actualizaciones pospuestas se ejecuten print ( parent : GetChildren ()) -- { Child dos } Warning Al usar state objects, fijate que los children viejos no ser\u00e1n destruidos, solo se les quitar\u00e1 el parent - depende de ti decidir cu\u00e1ndo/si los children necesitan ser destruidos. Si est\u00e1s usando un helper como ComputedPairs , la limpieza de instancias es controlada por defecto por ti (aunque esto es ajustable). \u00daltima Actualizaci\u00f3n de la Localizaci\u00f3n 10/10/2021","title":"Children"},{"location":"api-reference/api/children/#ejemplo-de-uso","text":"local example = New \"Folder\" { [ Children ] = New \"StringValue\" { Value = \"\u00a1Mi parent es la Folder!\" } }","title":"Ejemplo de Uso"},{"location":"api-reference/api/children/#procesando-children","text":"Un 'child' es definido (recursivamente) como: una instancia un state object o computed object que contenga children una array de children Dado que esta definici\u00f3n es recursiva, arrays y state objects pueden ser anidadas; es decir que el siguiente c\u00f3digo es v\u00e1lido: local example = New \"Folder\" { [ Children ] = { { { New \"StringValue\" { Value = \"\u00a1Mi parent es la Folder!\" } } } } } Este comportamiento es especialmente \u00fatil al trabajar con componentes - el siguiente componente puede regresar m\u00faltiples instancias para establecer sus parents sin interrumpir el c\u00f3digo junto a \u00e9l: local function Component ( props ) return { New \"TextLabel\" { LayoutOrder = 1 , Text = \"Instancia uno\" }, New \"TextLabel\" { LayoutOrder = 2 , Text = \"Instancia dos\" } } end local parent = New \"Frame\" { Children = { New \"UIListLayout\" { SortOrder = \"LayoutOrder\" }, Component {} } } Al usar state o computed object como child, se vincular\u00e1; cuando el valor del state object cambia, se le quitara el parent a los viejos children y se le establecer\u00e1 el parent a los nuevos children. Note Al igual que con propiedades bound, las actualizaciones son pospuestas al siguiente render step, por lo que el establecimiento de un parent no ocurrir\u00e1 al instante. local child1 = New \"Folder\" { Name = \"Child uno\" } local child2 = New \"Folder\" { Name = \"Child dos\" } local childState = State ( child1 ) local parent = New \"Folder\" { [ Children ] = childState } print ( parent : GetChildren ()) -- { Child uno } childState : set ( child2 ) wait ( 1 ) -- espera a que las actualizaciones pospuestas se ejecuten print ( parent : GetChildren ()) -- { Child dos } Warning Al usar state objects, fijate que los children viejos no ser\u00e1n destruidos, solo se les quitar\u00e1 el parent - depende de ti decidir cu\u00e1ndo/si los children necesitan ser destruidos. Si est\u00e1s usando un helper como ComputedPairs , la limpieza de instancias es controlada por defecto por ti (aunque esto es ajustable). \u00daltima Actualizaci\u00f3n de la Localizaci\u00f3n 10/10/2021","title":"Procesando Children"},{"location":"api-reference/api/compat/","text":"function Compat ( watchedState : State < any > ): Compat Construye y regresa un nuevo compatibility object, el cual escuchar\u00e1 eventos en el objeto watchedState dado. Compat est\u00e1 designado como una API para integrar Fusion con otro c\u00f3digo que no es de Fusion. Algunos usos como ejemplo incluyen sincronizar colores del tema a UIs que no son de Fusion, o guardar state objects en data stores cuando cambian. Warning Solo debes usar Compat para lidiar con c\u00f3digo que no sea de Fusion. Si est\u00e1s construyendo una interfaz con Fusion, ya existen herramientas reactivas para casi cualquier caso de uso, el cual puede ser optimizado por Fusion y dirigirse a un c\u00f3digo m\u00e1s limpio y representativo. Usar Compat en estas situaciones no es nada recomendable. Cambiar state objects en :onChange() es un antipatr\u00f3n particular que Compat puede incentivar a abusar. Si necesitas actualizar el valor de un state object cuando otro state object cambia, considera usar en cambio computed state . Para ver m\u00e1s detalles, mira este issue en GitHub. Par\u00e1metros \u00b6 watchedState: State<any> - un state object , computed object o otro state object para monitorear. M\u00e9todos del Objeto \u00b6 onChange() \u00b6 function Compat : onChange ( callback : () -> ()): () -> () Conecta el callback dado como un controlador de cambio, y regresa una funci\u00f3n que desconectar\u00e1 el callback. Cuando el valor de este watchedState de Compat cambia, el callback ser\u00e1 ejecutado. Fugas en la memoria de conexi\u00f3n Aseg\u00farate de desconectar cualquier controlador de cambio hecho usando esta funci\u00f3n una vez hayas terminado de usarlos. Siempre y cuando un controlador de cambio est\u00e9 conectado, este objeto Compat (y el watchedState ) ser\u00e1 conservado en la memoria, as\u00ed los cambios pueden ser detectados. Esto significa que, si no llamas la funci\u00f3n disconnect, puedes terminar conservando el state object en la memoria accidentalmente despu\u00e9s de que lo termines de usar. Ejemplo de Uso \u00b6 local numCoins = State ( 50 ) local compat = Compat ( numCoins ) local disconnect = numCoins : onChange ( function () print ( \"coins ahora es:\" , numCoins : get ()) end ) numCoins : set ( 25 ) -- se le hace print a 'coins ahora es: 25' -- \u00a1siempre limpia tus conexiones!! disconnect () \u00daltima Actualizaci\u00f3n de la Localizaci\u00f3n 10/10/2021","title":"Compat"},{"location":"api-reference/api/compat/#parametros","text":"watchedState: State<any> - un state object , computed object o otro state object para monitorear.","title":"Par\u00e1metros"},{"location":"api-reference/api/compat/#metodos-del-objeto","text":"","title":"M\u00e9todos del Objeto"},{"location":"api-reference/api/compat/#onchange","text":"function Compat : onChange ( callback : () -> ()): () -> () Conecta el callback dado como un controlador de cambio, y regresa una funci\u00f3n que desconectar\u00e1 el callback. Cuando el valor de este watchedState de Compat cambia, el callback ser\u00e1 ejecutado. Fugas en la memoria de conexi\u00f3n Aseg\u00farate de desconectar cualquier controlador de cambio hecho usando esta funci\u00f3n una vez hayas terminado de usarlos. Siempre y cuando un controlador de cambio est\u00e9 conectado, este objeto Compat (y el watchedState ) ser\u00e1 conservado en la memoria, as\u00ed los cambios pueden ser detectados. Esto significa que, si no llamas la funci\u00f3n disconnect, puedes terminar conservando el state object en la memoria accidentalmente despu\u00e9s de que lo termines de usar.","title":"onChange()"},{"location":"api-reference/api/compat/#ejemplo-de-uso","text":"local numCoins = State ( 50 ) local compat = Compat ( numCoins ) local disconnect = numCoins : onChange ( function () print ( \"coins ahora es:\" , numCoins : get ()) end ) numCoins : set ( 25 ) -- se le hace print a 'coins ahora es: 25' -- \u00a1siempre limpia tus conexiones!! disconnect () \u00daltima Actualizaci\u00f3n de la Localizaci\u00f3n 10/10/2021","title":"Ejemplo de Uso"},{"location":"api-reference/api/computed/","text":"function Computed ( callback : () -> any ): Computed Construye y regresa un nuevo computed object, usando el callback dado para calcular los valores del objeto basado en otros state objects o computed objects. Par\u00e1metros \u00b6 callback: () -> any - una funci\u00f3n que calcula y regresa el valor a usar para este computed object. M\u00e9todos del Objeto \u00b6 get() \u00b6 function Computed : get (): any Regresa el valor cach\u00e9 de este computed object, como regresa de la funci\u00f3n callback. Si las dependencias actualmente est\u00e1n siendo detectadas (ej. dentro de un computed callback), entonces este computed object ser\u00e1 usado como una dependencia. Ejemplo de Uso \u00b6 local numCoins = State ( 50 ) local doubleCoins = Computed ( function () return numCoins : get () * 2 end ) print ( doubleCoins : get ()) --> 100 numCoins : set ( 2 ) print ( doubleCoins : get ()) --> 4 Gesti\u00f3n de Dependencias \u00b6 Los computed objects autom\u00e1ticamente detectan dependencias usadas dentro de su callback cada vez que su callback se ejecuta. Esto significa, que al usar una funci\u00f3n como :get() en un state object, este registrar\u00e1 el state object como dependencia: local numCoins = State ( 50 ) local doubleCoins = Computed ( function () -- Fusion detecta que llamamos :get() en `numCoins`, y por esto agrega `numCoins` -- como una dependencia de este computed object. return numCoins : get () * 2 end ) Cuando una dependencia cambia su valor, el computed object re-ejecuta su callback para generar y almacenar el valor actual internamente. Este valor es luego expuesto mediante el m\u00e9todo :get() . Algo importante es que las dependencias son din\u00e1micas; puedes cambiar los valores de los que dependen tus computed objects, y las dependencias ser\u00e1n actualizadas para reducir actualizaciones innecesarias: Lua local stateA = State ( 5 ) local stateB = State ( 5 ) local selector = State ( \"A\" ) local computed = Computed ( function () print ( \"> \u00a1actualizando computed!\" ) local selected = selector : get () if selected == \"A\" then return stateA : get () elseif selected == \"B\" then return stateB : get () end end ) print ( \"se ha incrementado el state A (se espera una actualizaci\u00f3n debajo)\" ) stateA : set ( stateA : get () + 1 ) print ( \"se ha incrementado el state B (no se espera actualizaci\u00f3n)\" ) stateA : set ( stateA : get () + 1 ) print ( \"cambia para seleccionar B\" ) selector : set ( \"B\" ) print ( \"se ha incrementado el state A (no se espera actualizaci\u00f3n)\" ) stateA : set ( stateA : get () + 1 ) print ( \"se ha incrementado el state B (se espera una actualizaci\u00f3n debajo)\" ) stateA : set ( stateA : get () + 1 ) Output esperado > \u00a1actualizando computed! se ha incrementado el state A (se espera una actualizaci\u00f3n debajo) > \u00a1actualizando computed! se ha incrementado el state B (no se espera actualizaci\u00f3n) cambia para seleccionar B > \u00a1actualizando computed! se ha incrementado el state A (no se espera actualizaci\u00f3n) se ha incrementado el state B (se espera una actualizaci\u00f3n debajo) > \u00a1actualizando computed! Danger Af\u00e9rrate a usar state y computed objects dentro de tus c\u00f3mputos. Fusion puede detectar cuando usas estos objetos y escucha cuando hay cambios. Fusion no puede detectar cambios autom\u00e1ticamente cuando usas variables 'normales': local theVariable = \"Hola\" local badValue = Computed ( function () -- \u00a1no hagas esto! usa state o computed objects aqui return \"Di \" .. theVariable end ) print ( badValue : get ()) -- printea 'Di Hola' theVariable = \"Mundo\" print ( badValue : get ()) -- a\u00fan printea 'Di Hola' - \u00a1eso es un problema! Usando un state object aqui, Fusion puede actualizar el computed object correctamente, porque sabe que usamos el state object: local theVariable = State ( \"Hola\" ) local goodValue = Computed ( function () -- esto es mucho mejor - \u00a1Fusion puede detectar que usamos el state object! return \"Di \" .. theVariable : get () end ) print ( goodValue : get ()) -- printea 'Di Hola' theVariable : set ( \"Mundo\" ) print ( goodValue : get ()) -- printea 'Di Mundo' Esto tambi\u00e9n aplica a cualquier funci\u00f3n que pueda cambiarse por s\u00ed misma, como os.clock() . Si necesitas usarlas, guarda valores de la funci\u00f3n en un state object, y actualiza el valor de ese objeto tantas veces como sea necesario. \u00daltima Actualizaci\u00f3n de la Localizaci\u00f3n 10/10/2021","title":"Computed"},{"location":"api-reference/api/computed/#parametros","text":"callback: () -> any - una funci\u00f3n que calcula y regresa el valor a usar para este computed object.","title":"Par\u00e1metros"},{"location":"api-reference/api/computed/#metodos-del-objeto","text":"","title":"M\u00e9todos del Objeto"},{"location":"api-reference/api/computed/#get","text":"function Computed : get (): any Regresa el valor cach\u00e9 de este computed object, como regresa de la funci\u00f3n callback. Si las dependencias actualmente est\u00e1n siendo detectadas (ej. dentro de un computed callback), entonces este computed object ser\u00e1 usado como una dependencia.","title":"get()"},{"location":"api-reference/api/computed/#ejemplo-de-uso","text":"local numCoins = State ( 50 ) local doubleCoins = Computed ( function () return numCoins : get () * 2 end ) print ( doubleCoins : get ()) --> 100 numCoins : set ( 2 ) print ( doubleCoins : get ()) --> 4","title":"Ejemplo de Uso"},{"location":"api-reference/api/computed/#gestion-de-dependencias","text":"Los computed objects autom\u00e1ticamente detectan dependencias usadas dentro de su callback cada vez que su callback se ejecuta. Esto significa, que al usar una funci\u00f3n como :get() en un state object, este registrar\u00e1 el state object como dependencia: local numCoins = State ( 50 ) local doubleCoins = Computed ( function () -- Fusion detecta que llamamos :get() en `numCoins`, y por esto agrega `numCoins` -- como una dependencia de este computed object. return numCoins : get () * 2 end ) Cuando una dependencia cambia su valor, el computed object re-ejecuta su callback para generar y almacenar el valor actual internamente. Este valor es luego expuesto mediante el m\u00e9todo :get() . Algo importante es que las dependencias son din\u00e1micas; puedes cambiar los valores de los que dependen tus computed objects, y las dependencias ser\u00e1n actualizadas para reducir actualizaciones innecesarias: Lua local stateA = State ( 5 ) local stateB = State ( 5 ) local selector = State ( \"A\" ) local computed = Computed ( function () print ( \"> \u00a1actualizando computed!\" ) local selected = selector : get () if selected == \"A\" then return stateA : get () elseif selected == \"B\" then return stateB : get () end end ) print ( \"se ha incrementado el state A (se espera una actualizaci\u00f3n debajo)\" ) stateA : set ( stateA : get () + 1 ) print ( \"se ha incrementado el state B (no se espera actualizaci\u00f3n)\" ) stateA : set ( stateA : get () + 1 ) print ( \"cambia para seleccionar B\" ) selector : set ( \"B\" ) print ( \"se ha incrementado el state A (no se espera actualizaci\u00f3n)\" ) stateA : set ( stateA : get () + 1 ) print ( \"se ha incrementado el state B (se espera una actualizaci\u00f3n debajo)\" ) stateA : set ( stateA : get () + 1 ) Output esperado > \u00a1actualizando computed! se ha incrementado el state A (se espera una actualizaci\u00f3n debajo) > \u00a1actualizando computed! se ha incrementado el state B (no se espera actualizaci\u00f3n) cambia para seleccionar B > \u00a1actualizando computed! se ha incrementado el state A (no se espera actualizaci\u00f3n) se ha incrementado el state B (se espera una actualizaci\u00f3n debajo) > \u00a1actualizando computed! Danger Af\u00e9rrate a usar state y computed objects dentro de tus c\u00f3mputos. Fusion puede detectar cuando usas estos objetos y escucha cuando hay cambios. Fusion no puede detectar cambios autom\u00e1ticamente cuando usas variables 'normales': local theVariable = \"Hola\" local badValue = Computed ( function () -- \u00a1no hagas esto! usa state o computed objects aqui return \"Di \" .. theVariable end ) print ( badValue : get ()) -- printea 'Di Hola' theVariable = \"Mundo\" print ( badValue : get ()) -- a\u00fan printea 'Di Hola' - \u00a1eso es un problema! Usando un state object aqui, Fusion puede actualizar el computed object correctamente, porque sabe que usamos el state object: local theVariable = State ( \"Hola\" ) local goodValue = Computed ( function () -- esto es mucho mejor - \u00a1Fusion puede detectar que usamos el state object! return \"Di \" .. theVariable : get () end ) print ( goodValue : get ()) -- printea 'Di Hola' theVariable : set ( \"Mundo\" ) print ( goodValue : get ()) -- printea 'Di Mundo' Esto tambi\u00e9n aplica a cualquier funci\u00f3n que pueda cambiarse por s\u00ed misma, como os.clock() . Si necesitas usarlas, guarda valores de la funci\u00f3n en un state object, y actualiza el valor de ese objeto tantas veces como sea necesario. \u00daltima Actualizaci\u00f3n de la Localizaci\u00f3n 10/10/2021","title":"Gesti\u00f3n de Dependencias"},{"location":"api-reference/api/computedpairs/","text":"function ComputedPairs ( inputTable : StateOrValue < {[ any ]: any } > , processor : ( key : any , value : any ) -> any , destructor : (( any ) -> any ) ? ): Computed Construye y regresa un nuevo computed object, lo que genera una tabla procesando valores de otra tabla. La tabla ingresada puede ser pasada directamente, o dentro de un state object o computed object. La tabla generada tendr\u00e1 todas las keys de la tabla ingresada, pero todos los valores ser\u00e1n pasados mediante la funci\u00f3n processor . Cuando los valores son eliminados de la tabla generada, pueden ser pasados opcionalmente mediante una funci\u00f3n destructor . Esto permite que puedas limpiar algunos tipos adecuadamente como instancias - m\u00e1s detalles pueden ser encontrados en el tutorial. Par\u00e1metros \u00b6 inputTable: StateOrValue<{[any]: any}> - una tabla, o state object que contiene una tabla, que ser\u00e1 procesado por este ComputedPairs processor: (key: any, value: any) -> any - valores de la tabla ingresada ser\u00e1n pasados mediante esta funci\u00f3n y colocados en la tabla regresada por este objeto destructor: ((any) -> any)? - cuando un valor es eliminado de la tabla generada, ser\u00e1 pasado a esta funci\u00f3n para su limpieza. Si no se proporciona, se establece por defecto a una funci\u00f3n de limpieza como Maid. M\u00e9todos del Objeto \u00b6 get() \u00b6 function ComputedPairs : get (): any Regresa el valor almacenado de este computed object, el cual ser\u00e1 la tabla generada de key/value pairs. Si las dependencias actualmente est\u00e1n siendo detectadas (ej. dentro de un computed callback), entonces este computed object ser\u00e1 usado como una dependencia. Ejemplo de Uso \u00b6 local playerList = State ({ \"AxisAngles\" , \"boatbomber\" , \"Elttob\" , \"grilme99\" , \"Phalanxia\" , \"Reselim\" , \"thisfall\" }) local textLabels = ComputedPairs ( playerList , function ( key , value ) return New \"TextLabel\" { Text = value } end ) \u00daltima Actualizaci\u00f3n de la Localizaci\u00f3n 10/10/2021","title":"ComputedPairs"},{"location":"api-reference/api/computedpairs/#parametros","text":"inputTable: StateOrValue<{[any]: any}> - una tabla, o state object que contiene una tabla, que ser\u00e1 procesado por este ComputedPairs processor: (key: any, value: any) -> any - valores de la tabla ingresada ser\u00e1n pasados mediante esta funci\u00f3n y colocados en la tabla regresada por este objeto destructor: ((any) -> any)? - cuando un valor es eliminado de la tabla generada, ser\u00e1 pasado a esta funci\u00f3n para su limpieza. Si no se proporciona, se establece por defecto a una funci\u00f3n de limpieza como Maid.","title":"Par\u00e1metros"},{"location":"api-reference/api/computedpairs/#metodos-del-objeto","text":"","title":"M\u00e9todos del Objeto"},{"location":"api-reference/api/computedpairs/#get","text":"function ComputedPairs : get (): any Regresa el valor almacenado de este computed object, el cual ser\u00e1 la tabla generada de key/value pairs. Si las dependencias actualmente est\u00e1n siendo detectadas (ej. dentro de un computed callback), entonces este computed object ser\u00e1 usado como una dependencia.","title":"get()"},{"location":"api-reference/api/computedpairs/#ejemplo-de-uso","text":"local playerList = State ({ \"AxisAngles\" , \"boatbomber\" , \"Elttob\" , \"grilme99\" , \"Phalanxia\" , \"Reselim\" , \"thisfall\" }) local textLabels = ComputedPairs ( playerList , function ( key , value ) return New \"TextLabel\" { Text = value } end ) \u00daltima Actualizaci\u00f3n de la Localizaci\u00f3n 10/10/2021","title":"Ejemplo de Uso"},{"location":"api-reference/api/new/","text":"function New ( className : string ): ( props : {[ string | Symbol ]: any }) -> Instance Construye y regresa una nueva instancia con opciones para ajustar propiedades, handlers de eventos y otros atributos en la instancia de inmediato. La funci\u00f3n tiene par\u00e1metros currificados (curried) - cuando se llama New con el par\u00e1metro className , este regresara una segunda funci\u00f3n que acepta el par\u00e1metro props . Esto se hace para aprovechar el az\u00facar sint\u00e1ctico para llamadas a funciones en Lua: local myInstance = New ( \"Frame\" )({...}) -- es equivalente a: local myInstance = New \"Frame\" {...} Limpiando instancias Aseg\u00farate de destruir tus instancias adecuadamente. Sin usar un expl\u00edcito :Destroy() , es f\u00e1cil introducir accidentalmente fugas en la memoria (memory leaks). Para listas de instancias, puedes usar ComputedPairs , el cual viene con buenos valores predeterminados para la limpieza y cach\u00e9 de instancias. Par\u00e1metros \u00b6 className: string - el tipo de clase de la instancia que ser\u00e1 creada props: {[string | Symbol]: any} - una tabla de propiedades, controladores de eventos y otros atributos que ser\u00e1n aplicados a la instancia Ejemplo de Uso \u00b6 local myButton : TextButton = New \"TextButton\" { Parent = Players . LocalPlayer . PlayerGui , Position = UDim2 . fromScale ( .5 , .5 ), AnchorPoint = Vector2 . new ( .5 , .5 ), Size = UDim2 . fromOffset ( 200 , 50 ), Text = \"\u00a1Hola, mundo!\" , [ OnEvent \"Activated\" ] = function () print ( \"\u00a1El bot\u00f3n fue cliqueado!\" ) end , [ OnChange \"Name\" ] = function ( newName ) print ( \"El bot\u00f3n fue renombrado a:\" , newName ) end , [ Children ] = New \"UICorner\" { CornerRadius = UDim . new ( 0 , 8 ) } } Pasando Propiedades \u00b6 La tabla props usa una mezcla de keys de string y symbol para especificar atributos de la instancia que deben ser establecidos. Las keys de string son tratadas como declaraciones de propiedad - los valores pasados ser\u00e1n establecidos en la instancia: local example = New \"Part\" { -- establece la propiedad Position Position = Vector3 . new ( 1 , 2 , 3 ) } Adem\u00e1s, al pasar state objects o computed objects se vincula el valor de la propiedad; cuando el valor del objeto cambia, la propiedad tambi\u00e9n se actualiza en el siguiente render step: local myName = State ( \"Bob\" ) local example = New \"Part\" { -- al principio, el Name ser\u00e1 establecido a Bob Name = myName } -- se cambia el state object para guardar \"John\" -- en el siguiente render step, el Name de la parte ser\u00e1 cambiado a John myName : set ( \"John\" ) Fusion proporciona keys de symbol adicionales para otros prop\u00f3sitos especializados - mira la documentaci\u00f3n para m\u00e1s informaci\u00f3n en c\u00f3mo funciona cada uno: Children - hace una instancia parent de otras instancias OnEvent - conecta un callback a un evento en esta instancia OnChange - conecta un callback al evento GetPropertyChangedSignal para una propiedad en esta instancia Propiedades Predeterminadas \u00b6 La funci\u00f3n New proporciona su propia colecci\u00f3n de valores de propiedades 'sensible default' para algunos tipos de clase, que ser\u00e1n usados en lugar de los valores predeterminados de Roblox. Esto se hace para optar por no usar caracter\u00edsticas heredadas y valores predeterminados poco \u00fatiles. Puedes ver las propiedades predeterminadas que Fusion usa aqui: Propiedades predeterminadas ScreenGui = { ResetOnSpawn = false , ZIndexBehavior = \"Sibling\" }, BillboardGui = { ResetOnSpawn = false , ZIndexBehavior = \"Sibling\" }, SurfaceGui = { ResetOnSpawn = false , ZIndexBehavior = \"Sibling\" , SizingMode = \"PixelsPerStud\" , PixelsPerStud = 50 }, Frame = { BackgroundColor3 = Color3 . new ( 1 , 1 , 1 ), BorderColor3 = Color3 . new ( 0 , 0 , 0 ), BorderSizePixel = 0 }, ScrollingFrame = { BackgroundColor3 = Color3 . new ( 1 , 1 , 1 ), BorderColor3 = Color3 . new ( 0 , 0 , 0 ), BorderSizePixel = 0 , ScrollBarImageColor3 = Color3 . new ( 0 , 0 , 0 ) }, TextLabel = { BackgroundColor3 = Color3 . new ( 1 , 1 , 1 ), BorderColor3 = Color3 . new ( 0 , 0 , 0 ), BorderSizePixel = 0 , Font = \"SourceSans\" , Text = \"\" , TextColor3 = Color3 . new ( 0 , 0 , 0 ), TextSize = 14 }, TextButton = { BackgroundColor3 = Color3 . new ( 1 , 1 , 1 ), BorderColor3 = Color3 . new ( 0 , 0 , 0 ), BorderSizePixel = 0 , AutoButtonColor = false , Font = \"SourceSans\" , Text = \"\" , TextColor3 = Color3 . new ( 0 , 0 , 0 ), TextSize = 14 }, TextBox = { BackgroundColor3 = Color3 . new ( 1 , 1 , 1 ), BorderColor3 = Color3 . new ( 0 , 0 , 0 ), BorderSizePixel = 0 , ClearTextOnFocus = false , Font = \"SourceSans\" , Text = \"\" , TextColor3 = Color3 . new ( 0 , 0 , 0 ), TextSize = 14 }, ImageLabel = { BackgroundColor3 = Color3 . new ( 1 , 1 , 1 ), BorderColor3 = Color3 . new ( 0 , 0 , 0 ), BorderSizePixel = 0 }, ImageButton = { BackgroundColor3 = Color3 . new ( 1 , 1 , 1 ), BorderColor3 = Color3 . new ( 0 , 0 , 0 ), BorderSizePixel = 0 , AutoButtonColor = false }, ViewportFrame = { BackgroundColor3 = Color3 . new ( 1 , 1 , 1 ), BorderColor3 = Color3 . new ( 0 , 0 , 0 ), BorderSizePixel = 0 }, VideoFrame = { BackgroundColor3 = Color3 . new ( 1 , 1 , 1 ), BorderColor3 = Color3 . new ( 0 , 0 , 0 ), BorderSizePixel = 0 } \u00daltima Actualizaci\u00f3n de la Localizaci\u00f3n 10/10/2021","title":"New"},{"location":"api-reference/api/new/#parametros","text":"className: string - el tipo de clase de la instancia que ser\u00e1 creada props: {[string | Symbol]: any} - una tabla de propiedades, controladores de eventos y otros atributos que ser\u00e1n aplicados a la instancia","title":"Par\u00e1metros"},{"location":"api-reference/api/new/#ejemplo-de-uso","text":"local myButton : TextButton = New \"TextButton\" { Parent = Players . LocalPlayer . PlayerGui , Position = UDim2 . fromScale ( .5 , .5 ), AnchorPoint = Vector2 . new ( .5 , .5 ), Size = UDim2 . fromOffset ( 200 , 50 ), Text = \"\u00a1Hola, mundo!\" , [ OnEvent \"Activated\" ] = function () print ( \"\u00a1El bot\u00f3n fue cliqueado!\" ) end , [ OnChange \"Name\" ] = function ( newName ) print ( \"El bot\u00f3n fue renombrado a:\" , newName ) end , [ Children ] = New \"UICorner\" { CornerRadius = UDim . new ( 0 , 8 ) } }","title":"Ejemplo de Uso"},{"location":"api-reference/api/new/#pasando-propiedades","text":"La tabla props usa una mezcla de keys de string y symbol para especificar atributos de la instancia que deben ser establecidos. Las keys de string son tratadas como declaraciones de propiedad - los valores pasados ser\u00e1n establecidos en la instancia: local example = New \"Part\" { -- establece la propiedad Position Position = Vector3 . new ( 1 , 2 , 3 ) } Adem\u00e1s, al pasar state objects o computed objects se vincula el valor de la propiedad; cuando el valor del objeto cambia, la propiedad tambi\u00e9n se actualiza en el siguiente render step: local myName = State ( \"Bob\" ) local example = New \"Part\" { -- al principio, el Name ser\u00e1 establecido a Bob Name = myName } -- se cambia el state object para guardar \"John\" -- en el siguiente render step, el Name de la parte ser\u00e1 cambiado a John myName : set ( \"John\" ) Fusion proporciona keys de symbol adicionales para otros prop\u00f3sitos especializados - mira la documentaci\u00f3n para m\u00e1s informaci\u00f3n en c\u00f3mo funciona cada uno: Children - hace una instancia parent de otras instancias OnEvent - conecta un callback a un evento en esta instancia OnChange - conecta un callback al evento GetPropertyChangedSignal para una propiedad en esta instancia","title":"Pasando Propiedades"},{"location":"api-reference/api/new/#propiedades-predeterminadas","text":"La funci\u00f3n New proporciona su propia colecci\u00f3n de valores de propiedades 'sensible default' para algunos tipos de clase, que ser\u00e1n usados en lugar de los valores predeterminados de Roblox. Esto se hace para optar por no usar caracter\u00edsticas heredadas y valores predeterminados poco \u00fatiles. Puedes ver las propiedades predeterminadas que Fusion usa aqui: Propiedades predeterminadas ScreenGui = { ResetOnSpawn = false , ZIndexBehavior = \"Sibling\" }, BillboardGui = { ResetOnSpawn = false , ZIndexBehavior = \"Sibling\" }, SurfaceGui = { ResetOnSpawn = false , ZIndexBehavior = \"Sibling\" , SizingMode = \"PixelsPerStud\" , PixelsPerStud = 50 }, Frame = { BackgroundColor3 = Color3 . new ( 1 , 1 , 1 ), BorderColor3 = Color3 . new ( 0 , 0 , 0 ), BorderSizePixel = 0 }, ScrollingFrame = { BackgroundColor3 = Color3 . new ( 1 , 1 , 1 ), BorderColor3 = Color3 . new ( 0 , 0 , 0 ), BorderSizePixel = 0 , ScrollBarImageColor3 = Color3 . new ( 0 , 0 , 0 ) }, TextLabel = { BackgroundColor3 = Color3 . new ( 1 , 1 , 1 ), BorderColor3 = Color3 . new ( 0 , 0 , 0 ), BorderSizePixel = 0 , Font = \"SourceSans\" , Text = \"\" , TextColor3 = Color3 . new ( 0 , 0 , 0 ), TextSize = 14 }, TextButton = { BackgroundColor3 = Color3 . new ( 1 , 1 , 1 ), BorderColor3 = Color3 . new ( 0 , 0 , 0 ), BorderSizePixel = 0 , AutoButtonColor = false , Font = \"SourceSans\" , Text = \"\" , TextColor3 = Color3 . new ( 0 , 0 , 0 ), TextSize = 14 }, TextBox = { BackgroundColor3 = Color3 . new ( 1 , 1 , 1 ), BorderColor3 = Color3 . new ( 0 , 0 , 0 ), BorderSizePixel = 0 , ClearTextOnFocus = false , Font = \"SourceSans\" , Text = \"\" , TextColor3 = Color3 . new ( 0 , 0 , 0 ), TextSize = 14 }, ImageLabel = { BackgroundColor3 = Color3 . new ( 1 , 1 , 1 ), BorderColor3 = Color3 . new ( 0 , 0 , 0 ), BorderSizePixel = 0 }, ImageButton = { BackgroundColor3 = Color3 . new ( 1 , 1 , 1 ), BorderColor3 = Color3 . new ( 0 , 0 , 0 ), BorderSizePixel = 0 , AutoButtonColor = false }, ViewportFrame = { BackgroundColor3 = Color3 . new ( 1 , 1 , 1 ), BorderColor3 = Color3 . new ( 0 , 0 , 0 ), BorderSizePixel = 0 }, VideoFrame = { BackgroundColor3 = Color3 . new ( 1 , 1 , 1 ), BorderColor3 = Color3 . new ( 0 , 0 , 0 ), BorderSizePixel = 0 } \u00daltima Actualizaci\u00f3n de la Localizaci\u00f3n 10/10/2021","title":"Propiedades Predeterminadas"},{"location":"api-reference/api/onchange/","text":"function OnChange ( propertyName : string ): Symbol Genera s\u00edmbolos usados para denotar controladores de cambio de propiedades al trabajar con la funci\u00f3n New . Al usar este s\u00edmbolo como una key en la tabla de propiedades de New , se espera que el valor sea una funci\u00f3n callback. El callback ser\u00e1 conectado al evento GetPropertyChangedSignal de las propiedades en la instancia. Unlike normal property change handlers, the new value is passed in as an argument to the callback for convenience. Usando OnChange con el bound state Al pasar un state object o computed object como una propiedad, los cambios en el state solo afectar\u00e1n a la propiedad en el siguiente render step (un concepto conocido como 'deferred updating'). Debido a que OnChange se conecta a GetPropertyChangedSignal , es posible que se presenten errores off-by-one (por un paso) de un fotograma si dependes de OnChange para mantener otras cosas sincronizadas con la propiedad. En cambio opta por conectarse al state del evento onChange . Par\u00e1metros \u00b6 propertyName: string - la propiedad que monitorea por si hay cambios en la instancia Ejemplo de Uso \u00b6 local example = New \"TextBox\" { [ OnChange \"Text\" ] = function ( newText ) print ( \"Escribiste:\" , newText ) end } \u00daltima Actualizaci\u00f3n de la Localizaci\u00f3n 10/10/2021","title":"OnChange"},{"location":"api-reference/api/onchange/#parametros","text":"propertyName: string - la propiedad que monitorea por si hay cambios en la instancia","title":"Par\u00e1metros"},{"location":"api-reference/api/onchange/#ejemplo-de-uso","text":"local example = New \"TextBox\" { [ OnChange \"Text\" ] = function ( newText ) print ( \"Escribiste:\" , newText ) end } \u00daltima Actualizaci\u00f3n de la Localizaci\u00f3n 10/10/2021","title":"Ejemplo de Uso"},{"location":"api-reference/api/onevent/","text":"function OnEvent ( eventName : string ): Symbol Genera s\u00edmbolos usados para denotar controladores de eventos al trabajar con la funci\u00f3n New . Al usar este s\u00edmbolo como una key en la tabla de propiedades de New , se espera que el valor sea una funci\u00f3n callback, la cual ser\u00e1 conectada al evento dado en la instancia. La funci\u00f3n se comporta al igual que un controlador de eventos; recibe todo los argumentos del evento. La conexi\u00f3n se limpia autom\u00e1ticamente cuando la instancia se destruye. Par\u00e1metros \u00b6 eventName: string - el nombre del evento en la instancia Ejemplo de Uso \u00b6 local example = New \"TextButton\" { [ OnEvent \"Activated\" ] = function (...) print ( \"El evento Activated se ejecuta con args:\" , ...) end } \u00daltima Actualizaci\u00f3n de la Localizaci\u00f3n 10/10/2021","title":"OnEvent"},{"location":"api-reference/api/onevent/#parametros","text":"eventName: string - el nombre del evento en la instancia","title":"Par\u00e1metros"},{"location":"api-reference/api/onevent/#ejemplo-de-uso","text":"local example = New \"TextButton\" { [ OnEvent \"Activated\" ] = function (...) print ( \"El evento Activated se ejecuta con args:\" , ...) end } \u00daltima Actualizaci\u00f3n de la Localizaci\u00f3n 10/10/2021","title":"Ejemplo de Uso"},{"location":"api-reference/api/spring/","text":"function Spring ( goalValue : State < Animatable > , speed : number ? , dampingRatio : number ? ): Spring Construye y regresa un nuevo state object de Spring, el cual sigue el valor de goalValue . El valor de este objeto es simulado f\u00edsicamente, como si estuviera vinculado al valor del objetivo por un amortiguador. speed act\u00faa como un multiplicador de tiempo, duplicando speed corresponde a un movimiento que es dos veces m\u00e1s r\u00e1pido. dampingRatio afecta la fricci\u00f3n; 0 representa que no hay fricci\u00f3n, y 1 es solo la suficiente fricci\u00f3n para alcanzar el objetivo sin rebasamiento u oscilaci\u00f3n. Esto se puede variar libremente para ajustar la cantidad de fricci\u00f3n o 'rebote' que tiene el movimiento. Par\u00e1metros \u00b6 goalValue: State<Animatable> - el valor del objetivo que este objeto debe abordar speed: number? - cu\u00e1n r\u00e1pido este objeto debe abordar el objetivo dampingRatio: number? - escala cu\u00e1nta fricci\u00f3n es aplicada M\u00e9todos del Objeto \u00b6 get() \u00b6 function Spring : get (): any Regresa el valor guardado actualmente de este state object de Spring. Si las dependencias est\u00e1n siendo detectadas actualmente (ej. dentro de un computed callback), entonces este state object ser\u00e1 usado como una dependencia. Ejemplo de Uso \u00b6 local position = State ( UDim2 . fromScale ( 0.25 , 0.25 )) local ui = New \"Frame\" { Position = Spring ( position , 25 , 0.5 ) } local playerCount = State ( 0 ) local smoothPlayerCount = Spring ( playerCount ) local message = Computed ( function () return \"Actualmente en l\u00ednea: \" .. math.floor ( smoothPlayerCount : get ()) end ) \u00daltima Actualizaci\u00f3n de la Localizaci\u00f3n 10/10/2021","title":"Spring"},{"location":"api-reference/api/spring/#parametros","text":"goalValue: State<Animatable> - el valor del objetivo que este objeto debe abordar speed: number? - cu\u00e1n r\u00e1pido este objeto debe abordar el objetivo dampingRatio: number? - escala cu\u00e1nta fricci\u00f3n es aplicada","title":"Par\u00e1metros"},{"location":"api-reference/api/spring/#metodos-del-objeto","text":"","title":"M\u00e9todos del Objeto"},{"location":"api-reference/api/spring/#get","text":"function Spring : get (): any Regresa el valor guardado actualmente de este state object de Spring. Si las dependencias est\u00e1n siendo detectadas actualmente (ej. dentro de un computed callback), entonces este state object ser\u00e1 usado como una dependencia.","title":"get()"},{"location":"api-reference/api/spring/#ejemplo-de-uso","text":"local position = State ( UDim2 . fromScale ( 0.25 , 0.25 )) local ui = New \"Frame\" { Position = Spring ( position , 25 , 0.5 ) } local playerCount = State ( 0 ) local smoothPlayerCount = Spring ( playerCount ) local message = Computed ( function () return \"Actualmente en l\u00ednea: \" .. math.floor ( smoothPlayerCount : get ()) end ) \u00daltima Actualizaci\u00f3n de la Localizaci\u00f3n 10/10/2021","title":"Ejemplo de Uso"},{"location":"api-reference/api/state/","text":"function State ( initialValue : any ? ): State Construye y regresa un nuevo state object con un valor inicial opcional. Par\u00e1metros \u00b6 initialValue: any? - el valor que inicialmente deber\u00eda ser guardado en el state object. M\u00e9todos del Objeto \u00b6 get() \u00b6 function State : get (): any Regresa el valor actualmente guardado de este state object. Si las dependencias actualmente est\u00e1n siendo detectadas (ej. dentro de un computed callback), entonces este state object ser\u00e1 usado como una dependencia. set() \u00b6 function State : set ( newValue : any , force : boolean ? ) Establece el nuevo valor de este state object. Si los nuevos y antiguos valores son distintos, esto actualizar\u00e1 otros objetos que usen este state object. Sin embargo, si son los mismos, no se realizar\u00e1 la actualizaci\u00f3n. Forzar actualizaci\u00f3n Si quieres anular este comportamiento, puedes establecer force a true . Esto se asegurar\u00e1 que las actualizaciones siempre sean realizadas, a\u00fan si los nuevos y antiguos valores son iguales (medido por el operador ==). Esto es m\u00e1s \u00fatil al trabajar con tablas mutables. Sin embargo, ten mucho cuidado con esto y solo fuerza actualizaciones cuando lo necesites, por razones de rendimiento. Prueba primero una soluci\u00f3n que involucre tablas inmutables. El abuso de forzar actualizaciones puede llevar a c\u00f3digo no \u00f3ptimo que se actualiza redundantemente. Ejemplo de Uso \u00b6 local numCoins = State ( 50 ) print ( numCoins : get ()) --> 50 numCoins : set ( 25 ) print ( numCoins : get ()) --> 25 numCoins . onChange : Connect ( function () print ( \"Coins ha cambiado a:\" , numCoins : get ()) end ) \u00daltima Actualizaci\u00f3n de la Localizaci\u00f3n 10/10/2021","title":"State"},{"location":"api-reference/api/state/#parametros","text":"initialValue: any? - el valor que inicialmente deber\u00eda ser guardado en el state object.","title":"Par\u00e1metros"},{"location":"api-reference/api/state/#metodos-del-objeto","text":"","title":"M\u00e9todos del Objeto"},{"location":"api-reference/api/state/#get","text":"function State : get (): any Regresa el valor actualmente guardado de este state object. Si las dependencias actualmente est\u00e1n siendo detectadas (ej. dentro de un computed callback), entonces este state object ser\u00e1 usado como una dependencia.","title":"get()"},{"location":"api-reference/api/state/#set","text":"function State : set ( newValue : any , force : boolean ? ) Establece el nuevo valor de este state object. Si los nuevos y antiguos valores son distintos, esto actualizar\u00e1 otros objetos que usen este state object. Sin embargo, si son los mismos, no se realizar\u00e1 la actualizaci\u00f3n. Forzar actualizaci\u00f3n Si quieres anular este comportamiento, puedes establecer force a true . Esto se asegurar\u00e1 que las actualizaciones siempre sean realizadas, a\u00fan si los nuevos y antiguos valores son iguales (medido por el operador ==). Esto es m\u00e1s \u00fatil al trabajar con tablas mutables. Sin embargo, ten mucho cuidado con esto y solo fuerza actualizaciones cuando lo necesites, por razones de rendimiento. Prueba primero una soluci\u00f3n que involucre tablas inmutables. El abuso de forzar actualizaciones puede llevar a c\u00f3digo no \u00f3ptimo que se actualiza redundantemente.","title":"set()"},{"location":"api-reference/api/state/#ejemplo-de-uso","text":"local numCoins = State ( 50 ) print ( numCoins : get ()) --> 50 numCoins : set ( 25 ) print ( numCoins : get ()) --> 25 numCoins . onChange : Connect ( function () print ( \"Coins ha cambiado a:\" , numCoins : get ()) end ) \u00daltima Actualizaci\u00f3n de la Localizaci\u00f3n 10/10/2021","title":"Ejemplo de Uso"},{"location":"api-reference/api/tween/","text":"function Tween ( goalValue : State < Animatable > , tweenInfo : TweenInfo ? ): Tween Construye y regresa un nuevo state object de Tween, el cual sigue el valor de goalValue . Cuando el valor del objetivo cambia, el valor de este objeto es interpolado hacia el valor del objetivo usando el tweenInfo dado. Par\u00e1metros \u00b6 goalValue: State<Animatable> - el valor del objetivo que este objeto debe abordar tweenInfo: TweenInfo? - el tween usado para animar el valor de este objeto M\u00e9todos del Objeto \u00b6 get() \u00b6 function Tween : get (): any Regresa el actual valor guardado de este state object de Tween. Si las dependencias est\u00e1n siendo detectadas actualmente (ej. dentro de un computed callback), entonces este state object ser\u00e1 usado como una dependencia. Ejemplo de Uso \u00b6 local EASE = TweenInfo . new ( 0.5 , Enum . EasingStyle . Sine , Enum . EasingDirection . InOut ) local position = State ( UDim2 . fromScale ( 0.25 , 0.25 )) local ui = New \"Frame\" { Position = Tween ( position , EASE ) } local playerCount = State ( 0 ) local smoothPlayerCount = Tween ( playerCount ) local message = Computed ( function () return \"Actualmente en l\u00ednea: \" .. math.floor ( smoothPlayerCount : get ()) end ) \u00daltima Actualizaci\u00f3n de la Localizaci\u00f3n 10/10/2021","title":"Tween"},{"location":"api-reference/api/tween/#parametros","text":"goalValue: State<Animatable> - el valor del objetivo que este objeto debe abordar tweenInfo: TweenInfo? - el tween usado para animar el valor de este objeto","title":"Par\u00e1metros"},{"location":"api-reference/api/tween/#metodos-del-objeto","text":"","title":"M\u00e9todos del Objeto"},{"location":"api-reference/api/tween/#get","text":"function Tween : get (): any Regresa el actual valor guardado de este state object de Tween. Si las dependencias est\u00e1n siendo detectadas actualmente (ej. dentro de un computed callback), entonces este state object ser\u00e1 usado como una dependencia.","title":"get()"},{"location":"api-reference/api/tween/#ejemplo-de-uso","text":"local EASE = TweenInfo . new ( 0.5 , Enum . EasingStyle . Sine , Enum . EasingDirection . InOut ) local position = State ( UDim2 . fromScale ( 0.25 , 0.25 )) local ui = New \"Frame\" { Position = Tween ( position , EASE ) } local playerCount = State ( 0 ) local smoothPlayerCount = Tween ( playerCount ) local message = Computed ( function () return \"Actualmente en l\u00ednea: \" .. math.floor ( smoothPlayerCount : get ()) end ) \u00daltima Actualizaci\u00f3n de la Localizaci\u00f3n 10/10/2021","title":"Ejemplo de Uso"},{"location":"examples/","text":"En construcci\u00f3n Esta p\u00e1gina est\u00e1 en construcci\u00f3n - la informaci\u00f3n puede faltar o estar incompleta. \u00a1Bienvenido a la p\u00e1gina de Ejemplos! Aqu\u00ed, puedes encontrar una variedad de ejemplos y proyectos open-source, as\u00ed puedes ver como Fusion funciona en un entorno real. Obby Fusion \u00b6 Mira como Fusion puede ser usado para construir una interfaz m\u00ednima para un obby, con un contador de checkpoint y confetti simulado animados. Presiona aqu\u00ed para ver y editar el juego en Roblox. \u00daltima Actualizaci\u00f3n de la Localizaci\u00f3n 10/10/2021","title":"Inicio"},{"location":"examples/#obby-fusion","text":"Mira como Fusion puede ser usado para construir una interfaz m\u00ednima para un obby, con un contador de checkpoint y confetti simulado animados. Presiona aqu\u00ed para ver y editar el juego en Roblox. \u00daltima Actualizaci\u00f3n de la Localizaci\u00f3n 10/10/2021","title":"Obby Fusion"},{"location":"extras/","text":"Extras \u00b6 \u00a1Bienvenido a la secci\u00f3n de Extras! Aqu\u00ed, puedes encontrar lineamientos y assets para la marca Fusion, \u00a1descarga fondos y fondos de pantalla para tus dispositivos, y m\u00e1s! Derechos de Autor Fusion se desarrolla y mantiene en su repositorio original , esta p\u00e1gina es solo la versi\u00f3n de la documentaci\u00f3n localizada al espa\u00f1ol (el repositorio modificado se encuentra aqu\u00ed ). Todos los derechos sobre este repositorio le pertenecen a Elttob y a cualquier persona que llegue a contribuir al original. M\u00e1s informaci\u00f3n acerca de la licencia Usados Com\u00fanmente \u00b6 Fondos \u00daltima Actualizaci\u00f3n de la Localizaci\u00f3n 25/09/2021","title":"Inicio"},{"location":"extras/#extras","text":"\u00a1Bienvenido a la secci\u00f3n de Extras! Aqu\u00ed, puedes encontrar lineamientos y assets para la marca Fusion, \u00a1descarga fondos y fondos de pantalla para tus dispositivos, y m\u00e1s! Derechos de Autor Fusion se desarrolla y mantiene en su repositorio original , esta p\u00e1gina es solo la versi\u00f3n de la documentaci\u00f3n localizada al espa\u00f1ol (el repositorio modificado se encuentra aqu\u00ed ). Todos los derechos sobre este repositorio le pertenecen a Elttob y a cualquier persona que llegue a contribuir al original. M\u00e1s informaci\u00f3n acerca de la licencia","title":"Extras"},{"location":"extras/#usados-comunmente","text":"Fondos \u00daltima Actualizaci\u00f3n de la Localizaci\u00f3n 25/09/2021","title":"Usados Com\u00fanmente"},{"location":"extras/backgrounds/","text":"Todos los fondos est\u00e1n en el formato PNG, y han sido optimizados para estas resoluciones: Ultra ancho (7680 x 1440) Pantalla ancha (2560 x 1440) 3:2 (2256 x 1504) M\u00f3vil (1125 x 2436) Construcci\u00f3n \u00b6 El logo de Fusion, con l\u00edneas de construcci\u00f3n mostradas y otros patrones geom\u00e9tricos. El fondo es 100% negro, ideal para pantallas OLED. Ultra ancho Pantalla ancha 3:2 M\u00f3vil Brillo \u00b6 Un logo centrado de Fusion emitiendo luz en un fondo oscuro. El fondo es 100% negro, ideal para pantallas OLED. Ultra ancho Pantalla ancha 3:2 M\u00f3vil Brillo (Alterno) \u00b6 Un logo centrado de Fusion emitiendo luz en un fondo oscuro. Usa un dise\u00f1o alterno del logo, el cual ahora es usado para transmiciones en vivo. El fondo es 100% negro, ideal para pantallas OLED. Ultra ancho Pantalla ancha 3:2 M\u00f3vil \u00daltima Actualizaci\u00f3n de la Localizaci\u00f3n 25/09/2021","title":"Fondos"},{"location":"extras/backgrounds/#construccion","text":"El logo de Fusion, con l\u00edneas de construcci\u00f3n mostradas y otros patrones geom\u00e9tricos. El fondo es 100% negro, ideal para pantallas OLED. Ultra ancho Pantalla ancha 3:2 M\u00f3vil","title":"Construcci\u00f3n"},{"location":"extras/backgrounds/#brillo","text":"Un logo centrado de Fusion emitiendo luz en un fondo oscuro. El fondo es 100% negro, ideal para pantallas OLED. Ultra ancho Pantalla ancha 3:2 M\u00f3vil","title":"Brillo"},{"location":"extras/backgrounds/#brillo-alterno","text":"Un logo centrado de Fusion emitiendo luz en un fondo oscuro. Usa un dise\u00f1o alterno del logo, el cual ahora es usado para transmiciones en vivo. El fondo es 100% negro, ideal para pantallas OLED. Ultra ancho Pantalla ancha 3:2 M\u00f3vil \u00daltima Actualizaci\u00f3n de la Localizaci\u00f3n 25/09/2021","title":"Brillo (Alterno)"},{"location":"extras/branding/","text":"En construcci\u00f3n Esta p\u00e1gina est\u00e1 en construcci\u00f3n - la informaci\u00f3n puede faltar o estar incompleta. \u00daltima Actualizaci\u00f3n de la Localizaci\u00f3n 25/09/2021","title":"Branding"},{"location":"tutorials/","text":"\u00a1Bienvenido a la secci\u00f3n de tutoriales de Fusion! Aqui, aprenderas c\u00f3mo construir grandes interfaces con Fusion, a\u00fan si eres un completo novato en la biblioteca. Beta Temprana Fusion es actualmente un proyecto en curso. Hay muchas funciones que no funcionan, no est\u00e1n implementadas, no est\u00e1n documentadas por completo o tal vez ser\u00e1n modificadas o eliminadas. No recomendamos usar Fusion para ning\u00fan proyecto importante por ahora a menos que est\u00e9s dispuesto a hacer m\u00e1s trabajo en seguir los cambios. Versiones m\u00e1s estables y mantenidas a largo plazo de Fusion estar\u00e1n disponibles una vez Fusion pase la fase beta. Derechos de Autor Fusion se desarrolla y mantiene en su repositorio original , esta p\u00e1gina es solo la versi\u00f3n de la documentaci\u00f3n localizada al espa\u00f1ol (el repositorio modificado se encuentra aqu\u00ed ). Todos los derechos sobre este repositorio le pertenecen a Elttob y a cualquier persona que llegue a contribuir al original. M\u00e1s informaci\u00f3n acerca de la licencia Lo Que Debes Saber \u00b6 Estos tutoriales asumen que: Est\u00e1s c\u00f3modo con Roblox y el lenguaje de programaci\u00f3n Luau. \u00a1Estos tutoriales no son una introducci\u00f3n para programar! Si deseas aprender, mira el Roblox DevHub . Eres familiar en c\u00f3mo funciona la UI en Roblox. No tienes que ser un dise\u00f1ador - conocer sobre instancias, eventos y tipos de datos de UI como UDim2 y Color3 ser\u00e1 suficiente. Por supuesto, basado en tus conocimientos previos, encontrar\u00e1s algunos tutoriales m\u00e1s f\u00e1ciles o dif\u00edciles. Fusion est\u00e1 construido para ser f\u00e1cil de aprender, pero a\u00fan as\u00ed puede tomar un poco de tiempo aprender algunos conceptos, as\u00ed que no te desalientes C\u00f3mo Funcionan Estos Tutoriales \u00b6 Puedes encontrar los tutoriales en la barra de navegaci\u00f3n a tu izquierda. Los tutoriales son agrupados por categor\u00eda, y son dise\u00f1ados para explorar caracter\u00edsticas espec\u00edficas de Fusion: 'Fundamentos' presenta las ideas centrales de Fusion - creando instancias, guardando estados y respondiendo a eventos. 'Otros Fundamentos' se desarrolla en esas ideas centrales, agregando herramientas \u00fatiles para construir UIs m\u00e1s complejas. 'Animaci\u00f3n' demuestra c\u00f3mo agregar tweens, transiciones y f\u00edsicas de springs para darle vida a tu UI. Puedes hacerlos en orden (recomendado para novatos), o puedes dirigirte a un tutorial en especifico para dar un repaso r\u00e1pido. Tambi\u00e9n ver\u00e1s 'proyectos', el cual combina conceptos de tutoriales anteriores y muestra c\u00f3mo pueden interactuar y trabajar juntos en un entorno real. En el comienzo de cada tutorial, ver\u00e1s una secci\u00f3n titulada 'C\u00f3digo necesario'. Se ven as\u00ed - puedes presionarlos para expandirlos: C\u00f3digo necesario 1 2 3 4 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Fusion = require ( ReplicatedStorage . Fusion ) print ( \"\u00a1Esto es un ejemplo!\" ) Antes de comenzar cada tutorial, aseg\u00farate de copiar el c\u00f3digo en tu editor de codigo, para que puedas seguirlo adecuadamente. De manera similar, encontraras c\u00f3digo finalizado del tutorial al final, dentro de 'C\u00f3digo finalizado': C\u00f3digo finalizado 1 2 3 4 5 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Fusion = require ( ReplicatedStorage . Fusion ) print ( \"\u00a1Esto es un ejemplo!\" ) print ( \"Sup\u00f3n que agregamos c\u00f3digo aqu\u00ed durante el tutorial...\" ) Puedes usar el c\u00f3digo finalizado como una referencia si te quedas bloqueado - contendr\u00e1 el c\u00f3digo como si ya hubiera pasado todos los pasos del tutorial. Instalando Fusion \u00b6 Fusion es distribuido como un solo ModuleScript . Antes de comenzar, necesitar\u00e1s agregar este module script a tu juego. Aqu\u00ed te decimos c\u00f3mo: Fusion para Roblox Studio \u00b6 Si programas en Roblox Studio, aqu\u00ed te decimos como instalar Fusion: Pasos Dirigete a la p\u00e1gina de 'Releases' de Fusion . Ah\u00ed, podr\u00e1s encontrar la \u00faltima versi\u00f3n de Fusion. Debajo de 'Assets', presiona en el archivo .rbxm para descargarlo. Este contiene el module script de Fusion. En Roblox Studio, abre o crea un place. Da clic derecho en ReplicatedStorage, y selecciona 'Insert from File'. Encuentra el .rbxm que descargaste, y seleccionalo. Ahora deber\u00edas ver un ModuleScript llamado 'Fusion' dentro de ReplicatedStorage - \u00a1est\u00e1s listo para comenzar! Fusion para Editores Externos \u00b6 Si usas un editor externo para programar, y los sincronizas a Roblox usando un plugin, aqu\u00ed te decimos como instalar Fusion: Pasos (presiona para expandir) Dirigete a la p\u00e1gina de 'Releases' de Fusion . Ah\u00ed, podr\u00e1s encontrar la \u00faltima versi\u00f3n de Fusion. 2.Debajo de 'Assets', presiona en el archivo .zip para descargarlo. Dentro de este se encuentra una copia del repositorio de GitHub de Fusion. Dentro del zip, copia la carpeta src - puede que est\u00e9 dentro de otra carpeta. Pega src dentro de tu proyecto local, preferiblemente en tu carpeta shared , si tienes una. Renombra la carpeta de src a Fusion . Una vez est\u00e9 instalado, deber\u00edas ver Fusion aparecer en Studio cuando sincronices tu proyecto. Configurando Un Script De Prueba \u00b6 Ahora que ya has instalado Fusion, puedes configurar un local script para probar. Aqu\u00ed te decimos c\u00f3mo: Crea un LocalScript en un servicio como StarterGui o StarterPlayerScripts . Elimina el c\u00f3digo predeterminado, y pega el siguiente c\u00f3digo: 1 2 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Fusion = require ( ReplicatedStorage . Fusion ) Note Este c\u00f3digo asume que ya has instalado Fusion dentro de ReplicatedStorage. Si has instalado Fusion en otra parte, necesitar\u00e1s ajustar el require() para dirigirse a la ubicaci\u00f3n correcta. Si todo se ha configurado correctamente, puedes presionar 'Play' y todo deber\u00eda ejecutarse sin errores. Mi script no funciona - errores comunes Fusion is not a valid member of ReplicatedStorage \"ReplicatedStorage\" Si est\u00e1s viendo este error, entonces tu script no puede encontrar a Fusion. Vuelce a consultar la secci\u00f3n anterior y verifica de nuevo que has configurado todo adecuadamente. Si est\u00e1s usando la guia de instalacion anterior, tu ReplicatedStorage deber\u00eda verse algo as\u00ed: \u00daltima Actualizaci\u00f3n de la Localizaci\u00f3n 25/09/2021","title":"Empezar"},{"location":"tutorials/#lo-que-debes-saber","text":"Estos tutoriales asumen que: Est\u00e1s c\u00f3modo con Roblox y el lenguaje de programaci\u00f3n Luau. \u00a1Estos tutoriales no son una introducci\u00f3n para programar! Si deseas aprender, mira el Roblox DevHub . Eres familiar en c\u00f3mo funciona la UI en Roblox. No tienes que ser un dise\u00f1ador - conocer sobre instancias, eventos y tipos de datos de UI como UDim2 y Color3 ser\u00e1 suficiente. Por supuesto, basado en tus conocimientos previos, encontrar\u00e1s algunos tutoriales m\u00e1s f\u00e1ciles o dif\u00edciles. Fusion est\u00e1 construido para ser f\u00e1cil de aprender, pero a\u00fan as\u00ed puede tomar un poco de tiempo aprender algunos conceptos, as\u00ed que no te desalientes","title":"Lo Que Debes Saber"},{"location":"tutorials/#como-funcionan-estos-tutoriales","text":"Puedes encontrar los tutoriales en la barra de navegaci\u00f3n a tu izquierda. Los tutoriales son agrupados por categor\u00eda, y son dise\u00f1ados para explorar caracter\u00edsticas espec\u00edficas de Fusion: 'Fundamentos' presenta las ideas centrales de Fusion - creando instancias, guardando estados y respondiendo a eventos. 'Otros Fundamentos' se desarrolla en esas ideas centrales, agregando herramientas \u00fatiles para construir UIs m\u00e1s complejas. 'Animaci\u00f3n' demuestra c\u00f3mo agregar tweens, transiciones y f\u00edsicas de springs para darle vida a tu UI. Puedes hacerlos en orden (recomendado para novatos), o puedes dirigirte a un tutorial en especifico para dar un repaso r\u00e1pido. Tambi\u00e9n ver\u00e1s 'proyectos', el cual combina conceptos de tutoriales anteriores y muestra c\u00f3mo pueden interactuar y trabajar juntos en un entorno real. En el comienzo de cada tutorial, ver\u00e1s una secci\u00f3n titulada 'C\u00f3digo necesario'. Se ven as\u00ed - puedes presionarlos para expandirlos: C\u00f3digo necesario 1 2 3 4 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Fusion = require ( ReplicatedStorage . Fusion ) print ( \"\u00a1Esto es un ejemplo!\" ) Antes de comenzar cada tutorial, aseg\u00farate de copiar el c\u00f3digo en tu editor de codigo, para que puedas seguirlo adecuadamente. De manera similar, encontraras c\u00f3digo finalizado del tutorial al final, dentro de 'C\u00f3digo finalizado': C\u00f3digo finalizado 1 2 3 4 5 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Fusion = require ( ReplicatedStorage . Fusion ) print ( \"\u00a1Esto es un ejemplo!\" ) print ( \"Sup\u00f3n que agregamos c\u00f3digo aqu\u00ed durante el tutorial...\" ) Puedes usar el c\u00f3digo finalizado como una referencia si te quedas bloqueado - contendr\u00e1 el c\u00f3digo como si ya hubiera pasado todos los pasos del tutorial.","title":"C\u00f3mo Funcionan Estos Tutoriales"},{"location":"tutorials/#instalando-fusion","text":"Fusion es distribuido como un solo ModuleScript . Antes de comenzar, necesitar\u00e1s agregar este module script a tu juego. Aqu\u00ed te decimos c\u00f3mo:","title":"Instalando Fusion"},{"location":"tutorials/#fusion-para-roblox-studio","text":"Si programas en Roblox Studio, aqu\u00ed te decimos como instalar Fusion: Pasos Dirigete a la p\u00e1gina de 'Releases' de Fusion . Ah\u00ed, podr\u00e1s encontrar la \u00faltima versi\u00f3n de Fusion. Debajo de 'Assets', presiona en el archivo .rbxm para descargarlo. Este contiene el module script de Fusion. En Roblox Studio, abre o crea un place. Da clic derecho en ReplicatedStorage, y selecciona 'Insert from File'. Encuentra el .rbxm que descargaste, y seleccionalo. Ahora deber\u00edas ver un ModuleScript llamado 'Fusion' dentro de ReplicatedStorage - \u00a1est\u00e1s listo para comenzar!","title":"Fusion para Roblox Studio"},{"location":"tutorials/#fusion-para-editores-externos","text":"Si usas un editor externo para programar, y los sincronizas a Roblox usando un plugin, aqu\u00ed te decimos como instalar Fusion: Pasos (presiona para expandir) Dirigete a la p\u00e1gina de 'Releases' de Fusion . Ah\u00ed, podr\u00e1s encontrar la \u00faltima versi\u00f3n de Fusion. 2.Debajo de 'Assets', presiona en el archivo .zip para descargarlo. Dentro de este se encuentra una copia del repositorio de GitHub de Fusion. Dentro del zip, copia la carpeta src - puede que est\u00e9 dentro de otra carpeta. Pega src dentro de tu proyecto local, preferiblemente en tu carpeta shared , si tienes una. Renombra la carpeta de src a Fusion . Una vez est\u00e9 instalado, deber\u00edas ver Fusion aparecer en Studio cuando sincronices tu proyecto.","title":"Fusion para Editores Externos"},{"location":"tutorials/#configurando-un-script-de-prueba","text":"Ahora que ya has instalado Fusion, puedes configurar un local script para probar. Aqu\u00ed te decimos c\u00f3mo: Crea un LocalScript en un servicio como StarterGui o StarterPlayerScripts . Elimina el c\u00f3digo predeterminado, y pega el siguiente c\u00f3digo: 1 2 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Fusion = require ( ReplicatedStorage . Fusion ) Note Este c\u00f3digo asume que ya has instalado Fusion dentro de ReplicatedStorage. Si has instalado Fusion en otra parte, necesitar\u00e1s ajustar el require() para dirigirse a la ubicaci\u00f3n correcta. Si todo se ha configurado correctamente, puedes presionar 'Play' y todo deber\u00eda ejecutarse sin errores. Mi script no funciona - errores comunes Fusion is not a valid member of ReplicatedStorage \"ReplicatedStorage\" Si est\u00e1s viendo este error, entonces tu script no puede encontrar a Fusion. Vuelce a consultar la secci\u00f3n anterior y verifica de nuevo que has configurado todo adecuadamente. Si est\u00e1s usando la guia de instalacion anterior, tu ReplicatedStorage deber\u00eda verse algo as\u00ed: \u00daltima Actualizaci\u00f3n de la Localizaci\u00f3n 25/09/2021","title":"Configurando Un Script De Prueba"},{"location":"tutorials/animation/project-3/","text":"En construcci\u00f3n Esta p\u00e1gina est\u00e1 en construcci\u00f3n - la informaci\u00f3n puede faltar o estar incompleta. \u00daltima Actualizaci\u00f3n de la Localizaci\u00f3n 25/09/2021","title":"Proyecto 3: Switches"},{"location":"tutorials/animation/springs/","text":"En construcci\u00f3n Esta p\u00e1gina est\u00e1 en construcci\u00f3n - la informaci\u00f3n puede faltar o estar incompleta. \u00daltima Actualizaci\u00f3n de la Localizaci\u00f3n 25/09/2021","title":"Springs"},{"location":"tutorials/animation/tweens/","text":"En construcci\u00f3n Esta p\u00e1gina est\u00e1 en construcci\u00f3n - la informaci\u00f3n puede faltar o estar incompleta. \u00daltima Actualizaci\u00f3n de la Localizaci\u00f3n 25/09/2021","title":"Tweens"},{"location":"tutorials/fundamentals/changing-children/","text":"En construcci\u00f3n Esta p\u00e1gina est\u00e1 en construcci\u00f3n - la informaci\u00f3n puede faltar o estar incompleta. Pasando State a Children \u00b6 Incompleto Esta secci\u00f3n est\u00e1 incompleta - puede que se necesite agregar m\u00e1s detalle en el futuro. Anteriormente, encontramos que pod\u00edamos pasar state como propiedades para vincularlas: local message = State ( \"Hola\" ) local gui = New \"TextLabel\" { Text = message } message : set ( \"Mundo\" ) -- establece Text como Mundo El mismo principio funciona con [Children] - puedes pasarlo en un state object que contenga cualquier children que desees agregar, y se vincularan de manera similar: local child = State ( New \"Folder\" {}) local gui = New \"TextLabel\" { [ Children ] = child } child : set ( New \"ScreenGui\" ) -- cambia el child de la carpeta al screen gui local child1 = New \"Folder\" {} local child2 = New \"Folder\" {} local child3 = New \"Folder\" {} local children = State ({ child1 , child2 }) local gui = New \"TextLabel\" { [ Children ] = child } children : set ({ child2 , child3 }) -- remueve el parent del child1, y le asigna el parent al child2 Date cuenta de que cuando un child se remueve de esta manera, solo pierde el parent, no se destruye. Aseg\u00farate de destruir cualquier instancia que elimines si no est\u00e1s utilizando un ayudante como ComputedPairs. Actualizaciones Pospuestas \u00b6 Incompleto Esta secci\u00f3n est\u00e1 incompleta - puede que se necesite agregar m\u00e1s detalle en el futuro. Los cambios para vincular children est\u00e1n pospuestos hasta el siguiente render step, al igual que cambios para vincular propiedades. \u00daltima Actualizaci\u00f3n de la Localizaci\u00f3n 26/09/2021","title":"Cambiando Children"},{"location":"tutorials/fundamentals/changing-children/#pasando-state-a-children","text":"Incompleto Esta secci\u00f3n est\u00e1 incompleta - puede que se necesite agregar m\u00e1s detalle en el futuro. Anteriormente, encontramos que pod\u00edamos pasar state como propiedades para vincularlas: local message = State ( \"Hola\" ) local gui = New \"TextLabel\" { Text = message } message : set ( \"Mundo\" ) -- establece Text como Mundo El mismo principio funciona con [Children] - puedes pasarlo en un state object que contenga cualquier children que desees agregar, y se vincularan de manera similar: local child = State ( New \"Folder\" {}) local gui = New \"TextLabel\" { [ Children ] = child } child : set ( New \"ScreenGui\" ) -- cambia el child de la carpeta al screen gui local child1 = New \"Folder\" {} local child2 = New \"Folder\" {} local child3 = New \"Folder\" {} local children = State ({ child1 , child2 }) local gui = New \"TextLabel\" { [ Children ] = child } children : set ({ child2 , child3 }) -- remueve el parent del child1, y le asigna el parent al child2 Date cuenta de que cuando un child se remueve de esta manera, solo pierde el parent, no se destruye. Aseg\u00farate de destruir cualquier instancia que elimines si no est\u00e1s utilizando un ayudante como ComputedPairs.","title":"Pasando State a Children"},{"location":"tutorials/fundamentals/changing-children/#actualizaciones-pospuestas","text":"Incompleto Esta secci\u00f3n est\u00e1 incompleta - puede que se necesite agregar m\u00e1s detalle en el futuro. Los cambios para vincular children est\u00e1n pospuestos hasta el siguiente render step, al igual que cambios para vincular propiedades. \u00daltima Actualizaci\u00f3n de la Localizaci\u00f3n 26/09/2021","title":"Actualizaciones Pospuestas"},{"location":"tutorials/fundamentals/changing-properties/","text":"Ahora que ya sabemos c\u00f3mo representar y trabajar con state de la UI, aprendamos c\u00f3mo vincular propiedades a nuestro state de la UI para que podamos mostrar un mensaje en pantalla. C\u00f3digo necesario 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Players = game : GetService ( \"Players\" ) local Fusion = require ( ReplicatedStorage . Fusion ) local New = Fusion . New local Children = Fusion . Children local State = Fusion . State local Computed = Fusion . Computed local numPlayers = State ( 5 ) local message = Computed ( function () return \"Hay \" .. numPlayers : get () .. \" en l\u00ednea.\" end ) local gui = New \"ScreenGui\" { Parent = Players . LocalPlayer . PlayerGui , Name = \"ExampleGui\" , ResetOnSpawn = false , ZIndexBehavior = \"Sibling\" , [ Children ] = New \"TextLabel\" { Position = UDim2 . fromScale ( .5 , .5 ), AnchorPoint = Vector2 . new ( .5 , .5 ), Size = UDim2 . fromOffset ( 200 , 50 ) } } Pasando State a Propiedades \u00b6 En nuestro c\u00f3digo actual estamos usando state y computed objects para guardar y procesar algunos datos: 11 12 13 14 local numPlayers = State ( 5 ) local message = Computed ( function () return \"Hay \" .. numPlayers : get () .. \" en l\u00ednea.\" end ) Cuando usamos la funci\u00f3n New , podemos usar estos state objects como propiedades. En otras palabras, podemos establecer el Text de nuestro TextLabel para que sea nuestro estado message : 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 local numPlayers = State ( 5 ) local message = Computed ( function () return \"Hay \" .. numPlayers : get () .. \" en l\u00ednea.\" end ) local gui = New \"ScreenGui\" { Parent = Players . LocalPlayer . PlayerGui , Name = \"ExampleGui\" , ResetOnSpawn = false , ZIndexBehavior = \"Sibling\" , [ Children ] = New \"TextLabel\" { Position = UDim2 . fromScale ( .5 , .5 ), AnchorPoint = Vector2 . new ( .5 , .5 ), Size = UDim2 . fromOffset ( 200 , 50 ), Text = message } } Esto establecer\u00e1 el Text a lo que est\u00e9 guardado en message , y lo mantiene actualizado a medida que message se cambia. Para mantener las cosas organizadas, puedes crear el computed object directamente junto a la propiedad, para mantenerla cerca de donde se usa: 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 local numPlayers = State ( 5 ) local gui = New \"ScreenGui\" { Parent = Players . LocalPlayer . PlayerGui , Name = \"ExampleGui\" , ResetOnSpawn = false , ZIndexBehavior = \"Sibling\" , [ Children ] = New \"TextLabel\" { Position = UDim2 . fromScale ( .5 , .5 ), AnchorPoint = Vector2 . new ( .5 , .5 ), Size = UDim2 . fromOffset ( 200 , 50 ), Text = Computed ( function () return \"Hay \" .. numPlayers : get () .. \" en l\u00ednea.\" end ) } } Eso es todo lo que debes saber - es com\u00fan usar cualquier estado como propiedad cuando se usa la funci\u00f3n New . Actualizaciones Pospuestas \u00b6 Vale la pena saber que los cambios de propiedades no son aplicados de inmediato - son pospuestos hasta el siguiente render step. En este ejemplo, el valor del state object cambia muchas veces. Sin embargo, Fusion solo actualizar\u00e1 la propiedad en el siguiente render step, esto significa que solo veremos el \u00faltimo cambio tener efecto: Lua local state = State ( 1 ) local ins = New \"NumberValue\" { Value = state , [ OnChange \"Value\" ] = function ( newValue ) print ( \"El nuevo valor es:\" , newValue ) end ) } state : set ( 2 ) state : set ( 3 ) state : set ( 4 ) state : set ( 5 ) Output esperado El nuevo valor es: 5 Esto es hecho por prop\u00f3sitos de optimizaci\u00f3n; mientras es relativamente menos costoso actualizar state objects muchas veces por fotograma, es costoso actualizar instancias. Adem\u00e1s, no hay ning\u00fan motivo para actualizar una instancia tantas veces por fotograma, porque este solo se renderiza una vez. En casi todos los casos, esto es una optimizaci\u00f3n conveniente. Sin embargo, en unos pocos casos puede ser problem\u00e1tico. En concreto, en el ejemplo anterior, el controlador de OnChange no se ejecuta cada vez que el valor del state object cambia. En cambio, se ejecuta en el render step despu\u00e9s de que el state object cambia, porque es cuando la propiedad cambia en realidad. Esto puede conducir a errores off-by-one-frame (por un fotograma) si no eres cuidadoso, as\u00ed que s\u00e9 cauteloso en cuanto uses OnChange en propiedades que vincules al state. Eso es todo lo que tienes que saber para conectar propiedades con state - es un concepto simple pero fundamental para crear UIs din\u00e1micas e interactivas. C\u00f3digo finalizado 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Players = game : GetService ( \"Players\" ) local Fusion = require ( ReplicatedStorage . Fusion ) local New = Fusion . New local Children = Fusion . Children local State = Fusion . State local Computed = Fusion . Computed local numPlayers = State ( 5 ) local gui = New \"ScreenGui\" { Parent = Players . LocalPlayer . PlayerGui , Name = \"ExampleGui\" , ResetOnSpawn = false , ZIndexBehavior = \"Sibling\" , [ Children ] = New \"TextLabel\" { Position = UDim2 . fromScale ( .5 , .5 ), AnchorPoint = Vector2 . new ( .5 , .5 ), Size = UDim2 . fromOffset ( 200 , 50 ), Text = Computed ( function () return \"Hay \" .. numPlayers : get () .. \" jugadores en l\u00ednea.\" end ) } } \u00daltima Actualizaci\u00f3n de la Localizaci\u00f3n 30/09/2021","title":"Cambiando Propiedades"},{"location":"tutorials/fundamentals/changing-properties/#pasando-state-a-propiedades","text":"En nuestro c\u00f3digo actual estamos usando state y computed objects para guardar y procesar algunos datos: 11 12 13 14 local numPlayers = State ( 5 ) local message = Computed ( function () return \"Hay \" .. numPlayers : get () .. \" en l\u00ednea.\" end ) Cuando usamos la funci\u00f3n New , podemos usar estos state objects como propiedades. En otras palabras, podemos establecer el Text de nuestro TextLabel para que sea nuestro estado message : 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 local numPlayers = State ( 5 ) local message = Computed ( function () return \"Hay \" .. numPlayers : get () .. \" en l\u00ednea.\" end ) local gui = New \"ScreenGui\" { Parent = Players . LocalPlayer . PlayerGui , Name = \"ExampleGui\" , ResetOnSpawn = false , ZIndexBehavior = \"Sibling\" , [ Children ] = New \"TextLabel\" { Position = UDim2 . fromScale ( .5 , .5 ), AnchorPoint = Vector2 . new ( .5 , .5 ), Size = UDim2 . fromOffset ( 200 , 50 ), Text = message } } Esto establecer\u00e1 el Text a lo que est\u00e9 guardado en message , y lo mantiene actualizado a medida que message se cambia. Para mantener las cosas organizadas, puedes crear el computed object directamente junto a la propiedad, para mantenerla cerca de donde se usa: 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 local numPlayers = State ( 5 ) local gui = New \"ScreenGui\" { Parent = Players . LocalPlayer . PlayerGui , Name = \"ExampleGui\" , ResetOnSpawn = false , ZIndexBehavior = \"Sibling\" , [ Children ] = New \"TextLabel\" { Position = UDim2 . fromScale ( .5 , .5 ), AnchorPoint = Vector2 . new ( .5 , .5 ), Size = UDim2 . fromOffset ( 200 , 50 ), Text = Computed ( function () return \"Hay \" .. numPlayers : get () .. \" en l\u00ednea.\" end ) } } Eso es todo lo que debes saber - es com\u00fan usar cualquier estado como propiedad cuando se usa la funci\u00f3n New .","title":"Pasando State a Propiedades"},{"location":"tutorials/fundamentals/changing-properties/#actualizaciones-pospuestas","text":"Vale la pena saber que los cambios de propiedades no son aplicados de inmediato - son pospuestos hasta el siguiente render step. En este ejemplo, el valor del state object cambia muchas veces. Sin embargo, Fusion solo actualizar\u00e1 la propiedad en el siguiente render step, esto significa que solo veremos el \u00faltimo cambio tener efecto: Lua local state = State ( 1 ) local ins = New \"NumberValue\" { Value = state , [ OnChange \"Value\" ] = function ( newValue ) print ( \"El nuevo valor es:\" , newValue ) end ) } state : set ( 2 ) state : set ( 3 ) state : set ( 4 ) state : set ( 5 ) Output esperado El nuevo valor es: 5 Esto es hecho por prop\u00f3sitos de optimizaci\u00f3n; mientras es relativamente menos costoso actualizar state objects muchas veces por fotograma, es costoso actualizar instancias. Adem\u00e1s, no hay ning\u00fan motivo para actualizar una instancia tantas veces por fotograma, porque este solo se renderiza una vez. En casi todos los casos, esto es una optimizaci\u00f3n conveniente. Sin embargo, en unos pocos casos puede ser problem\u00e1tico. En concreto, en el ejemplo anterior, el controlador de OnChange no se ejecuta cada vez que el valor del state object cambia. En cambio, se ejecuta en el render step despu\u00e9s de que el state object cambia, porque es cuando la propiedad cambia en realidad. Esto puede conducir a errores off-by-one-frame (por un fotograma) si no eres cuidadoso, as\u00ed que s\u00e9 cauteloso en cuanto uses OnChange en propiedades que vincules al state. Eso es todo lo que tienes que saber para conectar propiedades con state - es un concepto simple pero fundamental para crear UIs din\u00e1micas e interactivas. C\u00f3digo finalizado 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Players = game : GetService ( \"Players\" ) local Fusion = require ( ReplicatedStorage . Fusion ) local New = Fusion . New local Children = Fusion . Children local State = Fusion . State local Computed = Fusion . Computed local numPlayers = State ( 5 ) local gui = New \"ScreenGui\" { Parent = Players . LocalPlayer . PlayerGui , Name = \"ExampleGui\" , ResetOnSpawn = false , ZIndexBehavior = \"Sibling\" , [ Children ] = New \"TextLabel\" { Position = UDim2 . fromScale ( .5 , .5 ), AnchorPoint = Vector2 . new ( .5 , .5 ), Size = UDim2 . fromOffset ( 200 , 50 ), Text = Computed ( function () return \"Hay \" .. numPlayers : get () .. \" jugadores en l\u00ednea.\" end ) } } \u00daltima Actualizaci\u00f3n de la Localizaci\u00f3n 30/09/2021","title":"Actualizaciones Pospuestas"},{"location":"tutorials/fundamentals/computations/","text":"Usualmente, no usamos state tal cual en nuestra UI; normalmente primero la procesamos. Aprendamos c\u00f3mo realizar c\u00f3mputos en nuestro state. C\u00f3digo necesario 1 2 3 4 5 6 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Fusion = require ( ReplicatedStorage . Fusion ) local State = Fusion . State local numPlayers = State ( 5 ) El Problema de C\u00f3mputo \u00b6 En desarrollo de UI, muchos valores son computados basados en otros valores. Por ejemplo, puedes computar un mensaje basado en el n\u00famero de jugadores en l\u00ednea: local numPlayers = 5 local message = \"Hay \" .. numPlayers .. \" jugadores en l\u00ednea.\" Sin embargo, hay un problema - cuando numPlayers cambia, tenemos que manualmente recalcular el valor message por nosotros mismos. Si no lo haces, entonces el mensaje mostrar\u00e1 el valor incorrecto de jugadores - un problema conocido como 'data desynchronisation'. Objetos Computados \u00b6 Para resolver este problema, Fusion introduce un segundo tipo de objeto - 'computed objects' . En vez de guardar un valor arreglado, ejecutan un c\u00e1lculo. Pi\u00e9nsalo como una hoja de c\u00e1lculo, en la cual puedes escribir una ecuaci\u00f3n que usa otros valores. Para usar computed objects, primero necesitamos importar el constructor Computed : 1 2 3 4 5 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Fusion = require ( ReplicatedStorage . Fusion ) local State = Fusion . State local Computed = Fusion . Computed Ahora, podemos crear un computed object llamando al constructor. Pasamos nuestro c\u00f3mputo como una funci\u00f3n: 7 8 9 10 local numPlayers = State ( 5 ) local message = Computed ( function () return \"Hay \" .. numPlayers : get () .. \" jugadores en l\u00ednea.\" end ) En cualquier momento, puedes conseguir el computed value con el m\u00e9todo :get() : Lua 7 8 9 10 11 12 local numPlayers = State ( 5 ) local message = Computed ( function () return \"Hay \" .. numPlayers : get () .. \" jugadores en l\u00ednea.\" end ) print ( message : get ()) Output esperado Hay 5 jugadores en l\u00ednea. Ahora para la magia - cuando sea que uses un state object como parte de tu c\u00f3mputo, el computed object se actualizar\u00e1 cuando el state object cambie: Lua 7 8 9 10 11 12 13 14 15 local numPlayers = State ( 5 ) local message = Computed ( function () return \"Hay \" .. numPlayers : get () .. \" jugadores en l\u00ednea.\" end ) print ( message : get ()) numPlayers : set ( 12 ) print ( message : get ()) Output esperado Hay 5 jugadores en l\u00ednea. Hay 12 jugadores en l\u00ednea. Esto resuelve nuestro problema anterior 'data desynchronisation' - no tenemos que recalcular manualmente el mensaje. En cambio, Fusion lo controla por nosotros, porque estamos guardando nuestro state en los objetos de Fusion. Esta es la idea b\u00e1sica de computed objects; te permiten naturalmente definir valores en t\u00e9rminos de otros valores. Peligro - Yielding El c\u00f3digo que est\u00e9 dentro de un computed callback nunca se deber\u00eda yieldiar. Mientras actualmente Fusion no muestra un error por esto, hay planes para cambiarlo. Yielding en un callback puede romper mucho c\u00f3digo de Fusion, lo cual depende de las actualizaciones a tus variables en ser instant\u00e1neas, por ejemplo manejo de dependencias. Tambi\u00e9n puede dirigirse a c\u00f3digo inconsistente internamente. Si necesitas realizar un llamado web cuando alg\u00fan state cambia, considera usar Compat(state):onChange() para vincular un listener, el cual es permitido de yildearse, y guardar el resultado del llamado web en un state object para usarlo en cualquier lugar: local playerID = State ( 1670764 ) -- mal - \u00a1esto se romper\u00e1! local playerData = Computed ( function () return ReplicatedStorage . GetPlayerData : InvokeServer ( playerID : get ()) end ) -- mejor - esto mueve el yielding fuera de cualquier state object de manera segura -- asegurate de cargar los datos por primera vez si es importante local playerData = State ( nil ) Compat ( playerData ): onChange ( function () playerData : set ( ReplicatedStorage . GetPlayerData : InvokeServer ( playerID : get ())) end ) En el futuro, hay planes de hacer el yielding del c\u00f3digo m\u00e1s f\u00e1cil de trabajar. Mira este issue por m\u00e1s detalles. Peligro - Usar non-state objects Af\u00e9rrate a usar state objects y computed objects dentro de tus c\u00f3mputos. Fusion puede detectar cuando usas estos objetos y escuchar cambios. Fusion no puede autom\u00e1ticamente detectar cambios cuando usas variables 'normales': local theVariable = \"Hola\" local badValue = Computed ( function () -- \u00a1no hagas esto! usa state o computed objects aqui return \"Di \" .. theVariable end ) print ( badValue : get ()) -- printea 'Di Hola' theVariable = \"Mundo\" print ( badValue : get ()) -- a\u00fan printea 'Di Hola' - \u00a1eso es un problema! Usando un state object aqui, Fusion puede actualizar el computed object correctamente, porque sabe que usamos el state object: local theVariable = State ( \"Hola\" ) local goodValue = Computed ( function () -- esto es mucho mejor - \u00a1Fusion puede detectar que usamos el state object! return \"Di \" .. theVariable : get () end ) print ( goodValue : get ()) -- printea 'Di Hola' theVariable : set ( \"Mundo\" ) print ( goodValue : get ()) -- printea 'Di Mundo' Esto tambi\u00e9n aplica a cualquier funci\u00f3n que pueden cambiarse por s\u00ed mismas, como os.clock() . Si necesitas usarlas, guarda valores de la funci\u00f3n en un state object, y actualiza el valor de ese objeto tantas veces como sea necesario. Ahora, hemos cubierto todo lo que necesitamos saber acerca de las herramientas b\u00e1sicas de state en Fusion. Usando computed objects y state objects juntos, puedes guardar y calcular valores f\u00e1cilmente mientras evitas bugs de desincronizaci\u00f3n de datos. C\u00f3digo finalizado 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Fusion = require ( ReplicatedStorage . Fusion ) local State = Fusion . State local Computed = Fusion . Computed local numPlayers = State ( 5 ) local message = Computed ( function () return \"Hay \" .. numPlayers : get () .. \" jugadores en l\u00ednea.\" end ) print ( message : get ()) numPlayers : set ( 12 ) print ( message : get ()) \u00daltima Actualizaci\u00f3n de la Localizaci\u00f3n 30/09/2021","title":"C\u00f3mputos"},{"location":"tutorials/fundamentals/computations/#el-problema-de-computo","text":"En desarrollo de UI, muchos valores son computados basados en otros valores. Por ejemplo, puedes computar un mensaje basado en el n\u00famero de jugadores en l\u00ednea: local numPlayers = 5 local message = \"Hay \" .. numPlayers .. \" jugadores en l\u00ednea.\" Sin embargo, hay un problema - cuando numPlayers cambia, tenemos que manualmente recalcular el valor message por nosotros mismos. Si no lo haces, entonces el mensaje mostrar\u00e1 el valor incorrecto de jugadores - un problema conocido como 'data desynchronisation'.","title":"El Problema de C\u00f3mputo"},{"location":"tutorials/fundamentals/computations/#objetos-computados","text":"Para resolver este problema, Fusion introduce un segundo tipo de objeto - 'computed objects' . En vez de guardar un valor arreglado, ejecutan un c\u00e1lculo. Pi\u00e9nsalo como una hoja de c\u00e1lculo, en la cual puedes escribir una ecuaci\u00f3n que usa otros valores. Para usar computed objects, primero necesitamos importar el constructor Computed : 1 2 3 4 5 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Fusion = require ( ReplicatedStorage . Fusion ) local State = Fusion . State local Computed = Fusion . Computed Ahora, podemos crear un computed object llamando al constructor. Pasamos nuestro c\u00f3mputo como una funci\u00f3n: 7 8 9 10 local numPlayers = State ( 5 ) local message = Computed ( function () return \"Hay \" .. numPlayers : get () .. \" jugadores en l\u00ednea.\" end ) En cualquier momento, puedes conseguir el computed value con el m\u00e9todo :get() : Lua 7 8 9 10 11 12 local numPlayers = State ( 5 ) local message = Computed ( function () return \"Hay \" .. numPlayers : get () .. \" jugadores en l\u00ednea.\" end ) print ( message : get ()) Output esperado Hay 5 jugadores en l\u00ednea. Ahora para la magia - cuando sea que uses un state object como parte de tu c\u00f3mputo, el computed object se actualizar\u00e1 cuando el state object cambie: Lua 7 8 9 10 11 12 13 14 15 local numPlayers = State ( 5 ) local message = Computed ( function () return \"Hay \" .. numPlayers : get () .. \" jugadores en l\u00ednea.\" end ) print ( message : get ()) numPlayers : set ( 12 ) print ( message : get ()) Output esperado Hay 5 jugadores en l\u00ednea. Hay 12 jugadores en l\u00ednea. Esto resuelve nuestro problema anterior 'data desynchronisation' - no tenemos que recalcular manualmente el mensaje. En cambio, Fusion lo controla por nosotros, porque estamos guardando nuestro state en los objetos de Fusion. Esta es la idea b\u00e1sica de computed objects; te permiten naturalmente definir valores en t\u00e9rminos de otros valores. Peligro - Yielding El c\u00f3digo que est\u00e9 dentro de un computed callback nunca se deber\u00eda yieldiar. Mientras actualmente Fusion no muestra un error por esto, hay planes para cambiarlo. Yielding en un callback puede romper mucho c\u00f3digo de Fusion, lo cual depende de las actualizaciones a tus variables en ser instant\u00e1neas, por ejemplo manejo de dependencias. Tambi\u00e9n puede dirigirse a c\u00f3digo inconsistente internamente. Si necesitas realizar un llamado web cuando alg\u00fan state cambia, considera usar Compat(state):onChange() para vincular un listener, el cual es permitido de yildearse, y guardar el resultado del llamado web en un state object para usarlo en cualquier lugar: local playerID = State ( 1670764 ) -- mal - \u00a1esto se romper\u00e1! local playerData = Computed ( function () return ReplicatedStorage . GetPlayerData : InvokeServer ( playerID : get ()) end ) -- mejor - esto mueve el yielding fuera de cualquier state object de manera segura -- asegurate de cargar los datos por primera vez si es importante local playerData = State ( nil ) Compat ( playerData ): onChange ( function () playerData : set ( ReplicatedStorage . GetPlayerData : InvokeServer ( playerID : get ())) end ) En el futuro, hay planes de hacer el yielding del c\u00f3digo m\u00e1s f\u00e1cil de trabajar. Mira este issue por m\u00e1s detalles. Peligro - Usar non-state objects Af\u00e9rrate a usar state objects y computed objects dentro de tus c\u00f3mputos. Fusion puede detectar cuando usas estos objetos y escuchar cambios. Fusion no puede autom\u00e1ticamente detectar cambios cuando usas variables 'normales': local theVariable = \"Hola\" local badValue = Computed ( function () -- \u00a1no hagas esto! usa state o computed objects aqui return \"Di \" .. theVariable end ) print ( badValue : get ()) -- printea 'Di Hola' theVariable = \"Mundo\" print ( badValue : get ()) -- a\u00fan printea 'Di Hola' - \u00a1eso es un problema! Usando un state object aqui, Fusion puede actualizar el computed object correctamente, porque sabe que usamos el state object: local theVariable = State ( \"Hola\" ) local goodValue = Computed ( function () -- esto es mucho mejor - \u00a1Fusion puede detectar que usamos el state object! return \"Di \" .. theVariable : get () end ) print ( goodValue : get ()) -- printea 'Di Hola' theVariable : set ( \"Mundo\" ) print ( goodValue : get ()) -- printea 'Di Mundo' Esto tambi\u00e9n aplica a cualquier funci\u00f3n que pueden cambiarse por s\u00ed mismas, como os.clock() . Si necesitas usarlas, guarda valores de la funci\u00f3n en un state object, y actualiza el valor de ese objeto tantas veces como sea necesario. Ahora, hemos cubierto todo lo que necesitamos saber acerca de las herramientas b\u00e1sicas de state en Fusion. Usando computed objects y state objects juntos, puedes guardar y calcular valores f\u00e1cilmente mientras evitas bugs de desincronizaci\u00f3n de datos. C\u00f3digo finalizado 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Fusion = require ( ReplicatedStorage . Fusion ) local State = Fusion . State local Computed = Fusion . Computed local numPlayers = State ( 5 ) local message = Computed ( function () return \"Hay \" .. numPlayers : get () .. \" jugadores en l\u00ednea.\" end ) print ( message : get ()) numPlayers : set ( 12 ) print ( message : get ()) \u00daltima Actualizaci\u00f3n de la Localizaci\u00f3n 30/09/2021","title":"Objetos Computados"},{"location":"tutorials/fundamentals/creating-ui/","text":"Ahora que tenemos Fusion en marcha, aprendamos a crear instancias desde un script de manera r\u00e1pida y ordenada. C\u00f3digo necesario 1 2 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Fusion = require ( ReplicatedStorage . Fusion ) Instancias desde C\u00f3digo \u00b6 En Fusion, tu creas todas las instancias de UI desde c\u00f3digo. Eso puede sonar contraproducente, pero eso pr\u00f3ximamente te permitir\u00e1 reusar f\u00e1cilmente tus componentes de UI y hacer uso de herramientas potentes para conectar tu UI y scripts del juego juntos. Para hacer la experiencia m\u00e1s agradable, Fusion introduce una alternativa a Instance.new que te permite construir instancias completas de golpe - llamada la funci\u00f3n New . Aqui esta un fragmento de c\u00f3digo de ejemplo usando New - puedes compararlo a Instance.new : New local myPart = New \"Part\" { Parent = workspace , Position = Vector3 . new ( 1 , 2 , 3 ), BrickColor = BrickColor . new ( \"Bright green\" ), Size = Vector3 . new ( 2 , 1 , 4 ) } Instance.new local myPart = Instance . new ( \"Part\" ) myPart . Position = Vector3 . new ( 1 , 2 , 3 ) myPart . BrickColor = BrickColor . new ( \"Bright green\" ) myPart . Size = Vector3 . new ( 2 , 1 , 4 ) myPart . Parent = workspace Note No necesitas par\u00e9ntesis () para New - solo escribe el nombre de la clase y sus propiedades como lo hemos hecho anteriormente. En el fragmento de c\u00f3digo anterior, la funci\u00f3n New : crea una nueva parte le da una posici\u00f3n, tama\u00f1o y color asigna el workspace como su parent regresa la parte, para que pueda ser guardada en myPart La funci\u00f3n New tiene muchas caracter\u00edsticas incorporadas, las cuales usar\u00e1s despu\u00e9s, pero por ahora la usaremos para establecer propiedades. Creando Un ScreenGui \u00b6 Usemos la funci\u00f3n New para crear un ScreenGui. Lo pondremos en nuestro PlayerGui, as\u00ed que necesitamos importar el servicio Players . 1 2 3 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Players = game : GetService ( \"Players\" ) local Fusion = require ( ReplicatedStorage . Fusion ) Tambi\u00e9n tendremos que importar New desde Fusion: 1 2 3 4 5 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Players = game : GetService ( \"Players\" ) local Fusion = require ( ReplicatedStorage . Fusion ) local New = Fusion . New Ahora podemos usar la funci\u00f3n New como hicimos en el fragmento anterior. Queremos crear un ScreenGui con estas propiedades: un nombre de 'MyFirstGui' ResetOnSpawn deshabilitado el ZIndexBehavior` establecido como 'Sibling' PlayerGui como su parent \u00bfQu\u00e9 hacen estas propiedades? Un nombre hace m\u00e1s f\u00e1cil encontrar nuestra UI en el Explorer. Deshabilitando ResetOnSpawn detiene que Roblox destruya nuestra UI despu\u00e9s de que reaparezcamos. ZIndexBehavior es m\u00e1s que todo preferencia, pero cambia como la UI es organizada por profundidad . Asignando el PlayerGui como su parent hace nuestra UI visible en la pantalla. El siguiente fragmento de c\u00f3digo hace todo esto por nosotros: 1 2 3 4 5 6 7 8 9 10 11 12 13 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Players = game : GetService ( \"Players\" ) local Fusion = require ( ReplicatedStorage . Fusion ) local New = Fusion . New local gui = New \"ScreenGui\" { Parent = Players . LocalPlayer . PlayerGui , Name = \"MyFirstGui\" , ResetOnSpawn = false , ZIndexBehavior = \"Sibling\" } Si presionas 'Play', deber\u00edas ver que un ScreenGui ha aparecido en tu PlayerGui, con todas las propiedades que hemos establecido: Esperamos que te est\u00e9s sintiendo c\u00f3modo con esta sintaxis - nos extenderemos en esto en la siguiente secci\u00f3n. Agregando un Child \u00b6 Ahora agreguemos un TextLabel con un mensaje y asignar su parent a nuestro ScreenGui. Para ayudar con esto, la funci\u00f3n New nos permite agregar children directamente a nuestra instancia. Para usar esta caracter\u00edstica, primero tendremos que importar Children desde Fusion: 1 2 3 4 5 6 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Players = game : GetService ( \"Players\" ) local Fusion = require ( ReplicatedStorage . Fusion ) local New = Fusion . New local Children = Fusion . Children Ahora podemos crear cualquier instancia como child de nuestro ScreenGui - solo pasalo usando [ Children ] como la key. Por ejemplo, aqu\u00ed estamos creando nuestro TextLabel, y agregandolo como un child: 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 local gui = New \"ScreenGui\" { Parent = Players . LocalPlayer . PlayerGui , Name = \"MyFirstGui\" , ResetOnSpawn = false , ZIndexBehavior = \"Sibling\" , [ Children ] = New \"TextLabel\" { Position = UDim2 . fromScale ( .5 , .5 ), AnchorPoint = Vector2 . new ( .5 , .5 ), Size = UDim2 . fromOffset ( 200 , 50 ), Text = \"Fusion es divertido :)\" } } Si ahora presionas 'Play', deber\u00edas ver un TextLabel en el centro de tu pantalla: M\u00faltiples Children \u00b6 Puedes agregar m\u00e1s de una instancia - Children permite usar arrays de instancias. Si deseamos m\u00faltiples TextLabels, podemos crear un array para mantener nuestros children: 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 local gui = New \"ScreenGui\" { Parent = Players . LocalPlayer . PlayerGui , Name = \"MyFirstGui\" , ResetOnSpawn = false , ZIndexBehavior = \"Sibling\" , [ Children ] = { New \"TextLabel\" { Position = UDim2 . fromScale ( .5 , .5 ), AnchorPoint = Vector2 . new ( .5 , .5 ), Size = UDim2 . fromOffset ( 200 , 50 ), Text = \"Fusion es divertido :)\" } } } Ahora, podemos agregar otro TextLabel al array, y este tambi\u00e9n tendr\u00e1 un parent: 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 local gui = New \"ScreenGui\" { Parent = Players . LocalPlayer . PlayerGui , Name = \"MyFirstGui\" , ResetOnSpawn = false , ZIndexBehavior = \"Sibling\" , [ Children ] = { New \"TextLabel\" { Position = UDim2 . fromScale ( .5 , .5 ), AnchorPoint = Vector2 . new ( .5 , .5 ), Size = UDim2 . fromOffset ( 200 , 50 ), Text = \"Fusion es divertido :)\" }, New \"TextLabel\" { Position = UDim2 . new ( .5 , 0 , .5 , 50 ), AnchorPoint = Vector2 . new ( .5 , .5 ), Size = UDim2 . fromOffset ( 200 , 50 ), Text = \"\u00a1Dos es mejor que uno!\" } } } Si presionas 'Play', deber\u00edas ver ambos TextLabels aparecer: Felicidades - \u00a1has aprendido a crear instancias simples con Fusion! Durante el curso de los siguientes tutoriales, ver\u00e1s usada esta sintaxis mucho, as\u00ed que tendr\u00e1s un poco de tiempo para acostumbrarte a esta. Es importante entender lo b\u00e1sico de la funci\u00f3n New , debido a que es usada a lo largo de casi todo el c\u00f3digo de Fusion. C\u00f3digo finalizado 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Players = game : GetService ( \"Players\" ) local Fusion = require ( ReplicatedStorage . Fusion ) local New = Fusion . New local Children = Fusion . Children local gui = New \"ScreenGui\" { Parent = Players . LocalPlayer . PlayerGui , Name = \"MyFirstGui\" , ResetOnSpawn = false , ZIndexBehavior = \"Sibling\" , [ Children ] = { New \"TextLabel\" { Position = UDim2 . fromScale ( .5 , .5 ), AnchorPoint = Vector2 . new ( .5 , .5 ), Size = UDim2 . fromOffset ( 200 , 50 ), Text = \"Fusion es divertido :)\" }, New \"TextLabel\" { Position = UDim2 . new ( .5 , 0 , .5 , 50 ), AnchorPoint = Vector2 . new ( .5 , .5 ), Size = UDim2 . fromOffset ( 200 , 50 ), Text = \"\u00a1Dos es mejor que uno!\" } } } \u00daltima Actualizaci\u00f3n de la Localizaci\u00f3n 27/09/2021","title":"Creando UI"},{"location":"tutorials/fundamentals/creating-ui/#instancias-desde-codigo","text":"En Fusion, tu creas todas las instancias de UI desde c\u00f3digo. Eso puede sonar contraproducente, pero eso pr\u00f3ximamente te permitir\u00e1 reusar f\u00e1cilmente tus componentes de UI y hacer uso de herramientas potentes para conectar tu UI y scripts del juego juntos. Para hacer la experiencia m\u00e1s agradable, Fusion introduce una alternativa a Instance.new que te permite construir instancias completas de golpe - llamada la funci\u00f3n New . Aqui esta un fragmento de c\u00f3digo de ejemplo usando New - puedes compararlo a Instance.new : New local myPart = New \"Part\" { Parent = workspace , Position = Vector3 . new ( 1 , 2 , 3 ), BrickColor = BrickColor . new ( \"Bright green\" ), Size = Vector3 . new ( 2 , 1 , 4 ) } Instance.new local myPart = Instance . new ( \"Part\" ) myPart . Position = Vector3 . new ( 1 , 2 , 3 ) myPart . BrickColor = BrickColor . new ( \"Bright green\" ) myPart . Size = Vector3 . new ( 2 , 1 , 4 ) myPart . Parent = workspace Note No necesitas par\u00e9ntesis () para New - solo escribe el nombre de la clase y sus propiedades como lo hemos hecho anteriormente. En el fragmento de c\u00f3digo anterior, la funci\u00f3n New : crea una nueva parte le da una posici\u00f3n, tama\u00f1o y color asigna el workspace como su parent regresa la parte, para que pueda ser guardada en myPart La funci\u00f3n New tiene muchas caracter\u00edsticas incorporadas, las cuales usar\u00e1s despu\u00e9s, pero por ahora la usaremos para establecer propiedades.","title":"Instancias desde C\u00f3digo"},{"location":"tutorials/fundamentals/creating-ui/#creando-un-screengui","text":"Usemos la funci\u00f3n New para crear un ScreenGui. Lo pondremos en nuestro PlayerGui, as\u00ed que necesitamos importar el servicio Players . 1 2 3 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Players = game : GetService ( \"Players\" ) local Fusion = require ( ReplicatedStorage . Fusion ) Tambi\u00e9n tendremos que importar New desde Fusion: 1 2 3 4 5 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Players = game : GetService ( \"Players\" ) local Fusion = require ( ReplicatedStorage . Fusion ) local New = Fusion . New Ahora podemos usar la funci\u00f3n New como hicimos en el fragmento anterior. Queremos crear un ScreenGui con estas propiedades: un nombre de 'MyFirstGui' ResetOnSpawn deshabilitado el ZIndexBehavior` establecido como 'Sibling' PlayerGui como su parent \u00bfQu\u00e9 hacen estas propiedades? Un nombre hace m\u00e1s f\u00e1cil encontrar nuestra UI en el Explorer. Deshabilitando ResetOnSpawn detiene que Roblox destruya nuestra UI despu\u00e9s de que reaparezcamos. ZIndexBehavior es m\u00e1s que todo preferencia, pero cambia como la UI es organizada por profundidad . Asignando el PlayerGui como su parent hace nuestra UI visible en la pantalla. El siguiente fragmento de c\u00f3digo hace todo esto por nosotros: 1 2 3 4 5 6 7 8 9 10 11 12 13 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Players = game : GetService ( \"Players\" ) local Fusion = require ( ReplicatedStorage . Fusion ) local New = Fusion . New local gui = New \"ScreenGui\" { Parent = Players . LocalPlayer . PlayerGui , Name = \"MyFirstGui\" , ResetOnSpawn = false , ZIndexBehavior = \"Sibling\" } Si presionas 'Play', deber\u00edas ver que un ScreenGui ha aparecido en tu PlayerGui, con todas las propiedades que hemos establecido: Esperamos que te est\u00e9s sintiendo c\u00f3modo con esta sintaxis - nos extenderemos en esto en la siguiente secci\u00f3n.","title":"Creando Un ScreenGui"},{"location":"tutorials/fundamentals/creating-ui/#agregando-un-child","text":"Ahora agreguemos un TextLabel con un mensaje y asignar su parent a nuestro ScreenGui. Para ayudar con esto, la funci\u00f3n New nos permite agregar children directamente a nuestra instancia. Para usar esta caracter\u00edstica, primero tendremos que importar Children desde Fusion: 1 2 3 4 5 6 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Players = game : GetService ( \"Players\" ) local Fusion = require ( ReplicatedStorage . Fusion ) local New = Fusion . New local Children = Fusion . Children Ahora podemos crear cualquier instancia como child de nuestro ScreenGui - solo pasalo usando [ Children ] como la key. Por ejemplo, aqu\u00ed estamos creando nuestro TextLabel, y agregandolo como un child: 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 local gui = New \"ScreenGui\" { Parent = Players . LocalPlayer . PlayerGui , Name = \"MyFirstGui\" , ResetOnSpawn = false , ZIndexBehavior = \"Sibling\" , [ Children ] = New \"TextLabel\" { Position = UDim2 . fromScale ( .5 , .5 ), AnchorPoint = Vector2 . new ( .5 , .5 ), Size = UDim2 . fromOffset ( 200 , 50 ), Text = \"Fusion es divertido :)\" } } Si ahora presionas 'Play', deber\u00edas ver un TextLabel en el centro de tu pantalla:","title":"Agregando un Child"},{"location":"tutorials/fundamentals/creating-ui/#multiples-children","text":"Puedes agregar m\u00e1s de una instancia - Children permite usar arrays de instancias. Si deseamos m\u00faltiples TextLabels, podemos crear un array para mantener nuestros children: 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 local gui = New \"ScreenGui\" { Parent = Players . LocalPlayer . PlayerGui , Name = \"MyFirstGui\" , ResetOnSpawn = false , ZIndexBehavior = \"Sibling\" , [ Children ] = { New \"TextLabel\" { Position = UDim2 . fromScale ( .5 , .5 ), AnchorPoint = Vector2 . new ( .5 , .5 ), Size = UDim2 . fromOffset ( 200 , 50 ), Text = \"Fusion es divertido :)\" } } } Ahora, podemos agregar otro TextLabel al array, y este tambi\u00e9n tendr\u00e1 un parent: 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 local gui = New \"ScreenGui\" { Parent = Players . LocalPlayer . PlayerGui , Name = \"MyFirstGui\" , ResetOnSpawn = false , ZIndexBehavior = \"Sibling\" , [ Children ] = { New \"TextLabel\" { Position = UDim2 . fromScale ( .5 , .5 ), AnchorPoint = Vector2 . new ( .5 , .5 ), Size = UDim2 . fromOffset ( 200 , 50 ), Text = \"Fusion es divertido :)\" }, New \"TextLabel\" { Position = UDim2 . new ( .5 , 0 , .5 , 50 ), AnchorPoint = Vector2 . new ( .5 , .5 ), Size = UDim2 . fromOffset ( 200 , 50 ), Text = \"\u00a1Dos es mejor que uno!\" } } } Si presionas 'Play', deber\u00edas ver ambos TextLabels aparecer: Felicidades - \u00a1has aprendido a crear instancias simples con Fusion! Durante el curso de los siguientes tutoriales, ver\u00e1s usada esta sintaxis mucho, as\u00ed que tendr\u00e1s un poco de tiempo para acostumbrarte a esta. Es importante entender lo b\u00e1sico de la funci\u00f3n New , debido a que es usada a lo largo de casi todo el c\u00f3digo de Fusion. C\u00f3digo finalizado 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Players = game : GetService ( \"Players\" ) local Fusion = require ( ReplicatedStorage . Fusion ) local New = Fusion . New local Children = Fusion . Children local gui = New \"ScreenGui\" { Parent = Players . LocalPlayer . PlayerGui , Name = \"MyFirstGui\" , ResetOnSpawn = false , ZIndexBehavior = \"Sibling\" , [ Children ] = { New \"TextLabel\" { Position = UDim2 . fromScale ( .5 , .5 ), AnchorPoint = Vector2 . new ( .5 , .5 ), Size = UDim2 . fromOffset ( 200 , 50 ), Text = \"Fusion es divertido :)\" }, New \"TextLabel\" { Position = UDim2 . new ( .5 , 0 , .5 , 50 ), AnchorPoint = Vector2 . new ( .5 , .5 ), Size = UDim2 . fromOffset ( 200 , 50 ), Text = \"\u00a1Dos es mejor que uno!\" } } } \u00daltima Actualizaci\u00f3n de la Localizaci\u00f3n 27/09/2021","title":"M\u00faltiples Children"},{"location":"tutorials/fundamentals/handling-events/","text":"Ahora que podemos crear instancias, aprendamos c\u00f3mo manejar eventos y cambios de propiedad. C\u00f3digo necesario 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Players = game : GetService ( \"Players\" ) local Fusion = require ( ReplicatedStorage . Fusion ) local New = Fusion . New local Children = Fusion . Children local gui = New \"ScreenGui\" { Parent = Players . LocalPlayer . PlayerGui , Name = \"MyFirstGui\" , ResetOnSpawn = false , ZIndexBehavior = \"Sibling\" , [ Children ] = { New \"TextButton\" { Position = UDim2 . new ( 0.5 , 0 , 0.5 , - 100 ), AnchorPoint = Vector2 . new ( .5 , .5 ), Size = UDim2 . fromOffset ( 200 , 50 ), Text = \"\u00a1Cliqueame!\" }, New \"TextBox\" { Position = UDim2 . new ( 0.5 , 0 , 0.5 , 100 ), AnchorPoint = Vector2 . new ( .5 , .5 ), Size = UDim2 . fromOffset ( 200 , 50 ), Text = \"\" , ClearTextOnFocus = false } } } Conectando a Eventos \u00b6 Dentro del c\u00f3digo anterior, notar\u00e1s un TextButton. Intentemos conectarle el evento Activated para detectar clics del mouse. Para ayudar con esto, New nos permite agregar controladores de eventos a nuestra instancia directamente. Para poder usar esta caracter\u00edstica, necesitamos importar OnEvent desde Fusion: 1 2 3 4 5 6 7 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Players = game : GetService ( \"Players\" ) local Fusion = require ( ReplicatedStorage . Fusion ) local New = Fusion . New local Children = Fusion . Children local OnEvent = Fusion . OnEvent Ahora puedes pasar funciones de control de eventos usando [ OnEvent \"EventName\" ] como la key. Como un ejemplo, aqu\u00ed estamos conectando una funci\u00f3n a nuestros TextButtons con el evento Activated : 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 ZIndexBehavior = \"Sibling\" , [ Children ] = { New \"TextButton\" { Position = UDim2 . fromScale ( .5 , .5 ), AnchorPoint = Vector2 . new ( .5 , .5 ), Size = UDim2 . fromOffset ( 200 , 50 ), Text = \"Fusion es divertido :)\" , [ OnEvent \"Activated\" ] = function (...) print ( \"\u00a1Cliqueado!\" , ...) end }, New \"TextBox\" { Position = UDim2 . new ( 0.5 , 0 , 0.5 , 100 ), Esto funciona como un regular :Connect() - recibir\u00e1s todos los argumentos de este evento. Aqu\u00ed, solo estamos les estamos haciendo print por prop\u00f3sitos de demostraci\u00f3n. Si presionas 'Play' y cliqueas el bot\u00f3n unas cuantas veces, deber\u00edas ver algo as\u00ed en el output: \u00a1Eso es todo lo que hay para el control de eventos! Fusion maneja las conexiones del evento por ti autom\u00e1ticamente. Respondiendo al Cambio \u00b6 Adem\u00e1s de eventos regulares, puedes escuchar eventos de cambio de propiedad (los eventos regresados por GetPropertyChangedSignal ). Para usar eventos de cambio de propiedad, necesitar\u00e1s importar OnChange : 1 2 3 4 5 6 7 8 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Players = game : GetService ( \"Players\" ) local Fusion = require ( ReplicatedStorage . Fusion ) local New = Fusion . New local Children = Fusion . Children local OnEvent = Fusion . OnEvent local OnChange = Fusion . OnChange Ahora puedes pasar funciones usando [ OnChange \"PropertyName\" ] como la key. Cuando la propiedad es cambiada, tu funci\u00f3n ser\u00e1 llamada con el nuevo valor como su \u00fanico argumento. Para demostrar esto, aqu\u00ed estamos haciendo print del texto en nuestro TextBox cuando sea que cambie: 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 [ OnEvent \"Activated\" ] = function (...) print ( \"!Cliqueado!\" , ...) end }, New \"TextBox\" { Position = UDim2 . new ( 0.5 , 0 , 0.5 , 100 ), AnchorPoint = Vector2 . new ( .5 , .5 ), Size = UDim2 . fromOffset ( 200 , 50 ), Text = \"\" , ClearTextOnFocus = false , [ OnChange \"Text\" ] = function ( newText ) print ( newText ) end } } } Ahora, si presionas 'Play' y empiezas a escribir dentro del TextBox, deber\u00edas ver el contenido del TextBox reflejado en el output por cada car\u00e1cter que escribes: Con esto, has cubierto todo lo que hay para saber de controladores de evento y cambio de propiedad. En tutoriales posteriores, esto ser\u00e1 \u00fatil para responder al input del usuario. C\u00f3digo finalizado 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Players = game : GetService ( \"Players\" ) local Fusion = require ( ReplicatedStorage . Fusion ) local New = Fusion . New local Children = Fusion . Children local OnEvent = Fusion . OnEvent local OnChange = Fusion . OnChange local gui = New \"ScreenGui\" { Parent = Players . LocalPlayer . PlayerGui , Name = \"MyFirstGui\" , ResetOnSpawn = false , ZIndexBehavior = \"Sibling\" , [ Children ] = { New \"TextButton\" { Position = UDim2 . new ( 0.5 , 0 , 0.5 , - 100 ), AnchorPoint = Vector2 . new ( .5 , .5 ), Size = UDim2 . fromOffset ( 200 , 50 ), Text = \"\u00a1Cliqueame!\" , [ OnEvent \"Activated\" ] = function (...) print ( \"\u00a1Cliqueado!\" , ...) end }, New \"TextBox\" { Position = UDim2 . new ( 0.5 , 0 , 0.5 , 100 ), AnchorPoint = Vector2 . new ( .5 , .5 ), Size = UDim2 . fromOffset ( 200 , 50 ), Text = \"\" , ClearTextOnFocus = false , [ OnChange \"Text\" ] = function ( newText ) print ( newText ) end } } } \u00daltima Actualizaci\u00f3n de la Localizaci\u00f3n 27/09/2021","title":"Manejando Eventos"},{"location":"tutorials/fundamentals/handling-events/#conectando-a-eventos","text":"Dentro del c\u00f3digo anterior, notar\u00e1s un TextButton. Intentemos conectarle el evento Activated para detectar clics del mouse. Para ayudar con esto, New nos permite agregar controladores de eventos a nuestra instancia directamente. Para poder usar esta caracter\u00edstica, necesitamos importar OnEvent desde Fusion: 1 2 3 4 5 6 7 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Players = game : GetService ( \"Players\" ) local Fusion = require ( ReplicatedStorage . Fusion ) local New = Fusion . New local Children = Fusion . Children local OnEvent = Fusion . OnEvent Ahora puedes pasar funciones de control de eventos usando [ OnEvent \"EventName\" ] como la key. Como un ejemplo, aqu\u00ed estamos conectando una funci\u00f3n a nuestros TextButtons con el evento Activated : 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 ZIndexBehavior = \"Sibling\" , [ Children ] = { New \"TextButton\" { Position = UDim2 . fromScale ( .5 , .5 ), AnchorPoint = Vector2 . new ( .5 , .5 ), Size = UDim2 . fromOffset ( 200 , 50 ), Text = \"Fusion es divertido :)\" , [ OnEvent \"Activated\" ] = function (...) print ( \"\u00a1Cliqueado!\" , ...) end }, New \"TextBox\" { Position = UDim2 . new ( 0.5 , 0 , 0.5 , 100 ), Esto funciona como un regular :Connect() - recibir\u00e1s todos los argumentos de este evento. Aqu\u00ed, solo estamos les estamos haciendo print por prop\u00f3sitos de demostraci\u00f3n. Si presionas 'Play' y cliqueas el bot\u00f3n unas cuantas veces, deber\u00edas ver algo as\u00ed en el output: \u00a1Eso es todo lo que hay para el control de eventos! Fusion maneja las conexiones del evento por ti autom\u00e1ticamente.","title":"Conectando a Eventos"},{"location":"tutorials/fundamentals/handling-events/#respondiendo-al-cambio","text":"Adem\u00e1s de eventos regulares, puedes escuchar eventos de cambio de propiedad (los eventos regresados por GetPropertyChangedSignal ). Para usar eventos de cambio de propiedad, necesitar\u00e1s importar OnChange : 1 2 3 4 5 6 7 8 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Players = game : GetService ( \"Players\" ) local Fusion = require ( ReplicatedStorage . Fusion ) local New = Fusion . New local Children = Fusion . Children local OnEvent = Fusion . OnEvent local OnChange = Fusion . OnChange Ahora puedes pasar funciones usando [ OnChange \"PropertyName\" ] como la key. Cuando la propiedad es cambiada, tu funci\u00f3n ser\u00e1 llamada con el nuevo valor como su \u00fanico argumento. Para demostrar esto, aqu\u00ed estamos haciendo print del texto en nuestro TextBox cuando sea que cambie: 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 [ OnEvent \"Activated\" ] = function (...) print ( \"!Cliqueado!\" , ...) end }, New \"TextBox\" { Position = UDim2 . new ( 0.5 , 0 , 0.5 , 100 ), AnchorPoint = Vector2 . new ( .5 , .5 ), Size = UDim2 . fromOffset ( 200 , 50 ), Text = \"\" , ClearTextOnFocus = false , [ OnChange \"Text\" ] = function ( newText ) print ( newText ) end } } } Ahora, si presionas 'Play' y empiezas a escribir dentro del TextBox, deber\u00edas ver el contenido del TextBox reflejado en el output por cada car\u00e1cter que escribes: Con esto, has cubierto todo lo que hay para saber de controladores de evento y cambio de propiedad. En tutoriales posteriores, esto ser\u00e1 \u00fatil para responder al input del usuario. C\u00f3digo finalizado 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Players = game : GetService ( \"Players\" ) local Fusion = require ( ReplicatedStorage . Fusion ) local New = Fusion . New local Children = Fusion . Children local OnEvent = Fusion . OnEvent local OnChange = Fusion . OnChange local gui = New \"ScreenGui\" { Parent = Players . LocalPlayer . PlayerGui , Name = \"MyFirstGui\" , ResetOnSpawn = false , ZIndexBehavior = \"Sibling\" , [ Children ] = { New \"TextButton\" { Position = UDim2 . new ( 0.5 , 0 , 0.5 , - 100 ), AnchorPoint = Vector2 . new ( .5 , .5 ), Size = UDim2 . fromOffset ( 200 , 50 ), Text = \"\u00a1Cliqueame!\" , [ OnEvent \"Activated\" ] = function (...) print ( \"\u00a1Cliqueado!\" , ...) end }, New \"TextBox\" { Position = UDim2 . new ( 0.5 , 0 , 0.5 , 100 ), AnchorPoint = Vector2 . new ( .5 , .5 ), Size = UDim2 . fromOffset ( 200 , 50 ), Text = \"\" , ClearTextOnFocus = false , [ OnChange \"Text\" ] = function ( newText ) print ( newText ) end } } } \u00daltima Actualizaci\u00f3n de la Localizaci\u00f3n 27/09/2021","title":"Respondiendo al Cambio"},{"location":"tutorials/fundamentals/project-1/","text":"En construcci\u00f3n Esta p\u00e1gina est\u00e1 en construcci\u00f3n - la informaci\u00f3n puede faltar o estar incompleta. Aplicando todo lo que hemos aprendido hasta el momento, construyamos una UI para ver como las herramientas b\u00e1sicas de Fusion trabajan juntas en un proyecto verdadero. C\u00f3digo necesario 1 2 3 4 5 6 7 8 9 10 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Players = game : GetService ( \"Players\" ) local Fusion = require ( ReplicatedStorage . Fusion ) local New = Fusion . New local Children = Fusion . Children local OnEvent = Fusion . OnEvent local State = Fusion . State local Computed = Fusion . Computed Construyendo La UI \u00b6 Crearemos un bot\u00f3n el cual muestra la cantidad de veces que ha sido bloqueado - esto es un ejemplo com\u00fan usado como introducci\u00f3n a la UI en muchas bibliotecas y frameworks porque este involucra UI. Comenzaremos creando un ScreenGui para mantener nuestro bot\u00f3n: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Players = game : GetService ( \"Players\" ) local Fusion = require ( ReplicatedStorage . Fusion ) local New = Fusion . New local Children = Fusion . Children local OnEvent = Fusion . OnEvent local State = Fusion . State local Computed = Fusion . Computed local gui = New \"ScreenGui\" { Parent = Players . LocalPlayer . PlayerGui , Name = \"CountingGui\" , ZIndexBehavior = \"Sibling\" } Luego, crearemos un TextButton que podemos cliquear, y un mensaje en un TextLabel para mostrar eventualmente la cantidad de clics realizados. 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 local gui = New \"ScreenGui\" { Parent = Players . LocalPlayer . PlayerGui , Name = \"CountingGui\" , ZIndexBehavior = \"Sibling\" , [ Children ] = { New \"TextButton\" { Name = \"ClickButton\" , Position = UDim2 . fromScale ( .5 , .5 ), Size = UDim2 . fromOffset ( 200 , 50 ), AnchorPoint = Vector2 . new ( .5 , .5 ), BackgroundColor3 = Color3 . fromRGB ( 85 , 255 , 0 ), Text = \"\u00a1Cliqueame!\" }, New \"TextLabel\" { Name = \"Message\" , Position = UDim2 . new ( 0.5 , 0 , 0.5 , 100 ), Size = UDim2 . fromOffset ( 200 , 50 ), AnchorPoint = Vector2 . new ( .5 , .5 ), BackgroundColor3 = Color3 . fromRGB ( 255 , 255 , 255 ), Text = \"Mensaje provisional...\" } } } Con estas tres instancias, tenemos suficiente con lo que trabajar por lo que queda del tutorial. Ejecutando el c\u00f3digo anterior nos da esto: Agregando State \u00b6 Ahora, agreguemos algunos state para hacer nuestra UI din\u00e1mica. Comencemos con un state object para guardar el n\u00famero de clics: 12 13 14 15 16 17 18 19 20 local numClicks = State ( 0 ) local gui = New \"ScreenGui\" { Parent = Players . LocalPlayer . PlayerGui , Name = \"CountingGui\" , ZIndexBehavior = \"Sibling\" , [ Children ] = { Ahora, podemos reemplazar el texto provisional con un computed state, para tornar el n\u00famero de clics dentro de un mensaje completo: 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 Text = \"\u00a1Cliqueame!\" }, New \"TextLabel\" { Name = \"Message\" , Position = UDim2 . new ( 0.5 , 0 , 0.5 , 100 ), Size = UDim2 . fromOffset ( 200 , 50 ), AnchorPoint = Vector2 . new ( .5 , .5 ), BackgroundColor3 = Color3 . fromRGB ( 255 , 255 , 255 ), Text = Computed ( function () return \"Cliqueaste \" .. numClicks : get () .. \" veces.\" end ) } } } Ahora te dar\u00e1s cuenta que el mensaje refleja en el texto el n\u00famero de clics guardados en numClicks : Monitoreando Clics \u00b6 Ahora que ya tenemos nuestra UI en su lugar y funciona con nuestro state, solo tenemos que incrementar el n\u00famero de clics guardados en numClicks cuando liqueamos el bot\u00f3n. Para comenzar, agreguemos un handler de OnEvent para el evento Activated del bot\u00f3n. Esto se ejecutar\u00e1 cuando cliqueamos el bot\u00f3n. [ Children ] = { New \"TextButton\" { Name = \"ClickButton\" , Position = UDim2 . fromScale ( .5 , .5 ), Size = UDim2 . fromOffset ( 200 , 50 ), AnchorPoint = Vector2 . new ( .5 , .5 ), BackgroundColor3 = Color3 . fromRGB ( 85 , 255 , 0 ), Text = \"\u00a1Cliqueame!\" , [ OnEvent \"Activated\" ] = function () -- \u00a1el bot\u00f3n fue cliqueado! -- TODO: incrementar el state end }, New \"TextLabel\" { Luego, para incrementar el state, podemos usar :get() para conseguir el n\u00famero de clics, sumarle uno, y establecerlo con :set() con el nuevo valor: [ Children ] = { New \"TextButton\" { Name = \"ClickButton\" , Position = UDim2 . fromScale ( .5 , .5 ), Size = UDim2 . fromOffset ( 200 , 50 ), AnchorPoint = Vector2 . new ( .5 , .5 ), BackgroundColor3 = Color3 . fromRGB ( 85 , 255 , 0 ), Text = \"\u00a1Cliqueame!\" , [ OnEvent \"Activated\" ] = function () -- \u00a1el bot\u00f3n fue cliqueado! numClicks : set ( numClicks : get () + 1 ) end }, New \"TextLabel\" { Eso es todo - intenta cliquear el bot\u00f3n, y observa el mensaje cambiar en respuesta: Si has logrado seguir a lo largo del tutorial, felicidades - \u00a1ahora deber\u00edas tener un buen conocimiento en los conceptos fundamentales de Fusion! Con solo estas herramientas, ser\u00e1s capaz de construir casi todo lo que puedas pensar. Sin embargo, Fusion a\u00fan tiene m\u00e1s herramientas disponibles para hacer tu c\u00f3digo m\u00e1s f\u00e1cil y simple de gestionar - cubriremos esto en 'Otros Fundamentos' . \u00daltima Actualizaci\u00f3n de la Localizaci\u00f3n 26/09/2021","title":"Proyecto 1: Contando Clics"},{"location":"tutorials/fundamentals/project-1/#construyendo-la-ui","text":"Crearemos un bot\u00f3n el cual muestra la cantidad de veces que ha sido bloqueado - esto es un ejemplo com\u00fan usado como introducci\u00f3n a la UI en muchas bibliotecas y frameworks porque este involucra UI. Comenzaremos creando un ScreenGui para mantener nuestro bot\u00f3n: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Players = game : GetService ( \"Players\" ) local Fusion = require ( ReplicatedStorage . Fusion ) local New = Fusion . New local Children = Fusion . Children local OnEvent = Fusion . OnEvent local State = Fusion . State local Computed = Fusion . Computed local gui = New \"ScreenGui\" { Parent = Players . LocalPlayer . PlayerGui , Name = \"CountingGui\" , ZIndexBehavior = \"Sibling\" } Luego, crearemos un TextButton que podemos cliquear, y un mensaje en un TextLabel para mostrar eventualmente la cantidad de clics realizados. 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 local gui = New \"ScreenGui\" { Parent = Players . LocalPlayer . PlayerGui , Name = \"CountingGui\" , ZIndexBehavior = \"Sibling\" , [ Children ] = { New \"TextButton\" { Name = \"ClickButton\" , Position = UDim2 . fromScale ( .5 , .5 ), Size = UDim2 . fromOffset ( 200 , 50 ), AnchorPoint = Vector2 . new ( .5 , .5 ), BackgroundColor3 = Color3 . fromRGB ( 85 , 255 , 0 ), Text = \"\u00a1Cliqueame!\" }, New \"TextLabel\" { Name = \"Message\" , Position = UDim2 . new ( 0.5 , 0 , 0.5 , 100 ), Size = UDim2 . fromOffset ( 200 , 50 ), AnchorPoint = Vector2 . new ( .5 , .5 ), BackgroundColor3 = Color3 . fromRGB ( 255 , 255 , 255 ), Text = \"Mensaje provisional...\" } } } Con estas tres instancias, tenemos suficiente con lo que trabajar por lo que queda del tutorial. Ejecutando el c\u00f3digo anterior nos da esto:","title":"Construyendo La UI"},{"location":"tutorials/fundamentals/project-1/#agregando-state","text":"Ahora, agreguemos algunos state para hacer nuestra UI din\u00e1mica. Comencemos con un state object para guardar el n\u00famero de clics: 12 13 14 15 16 17 18 19 20 local numClicks = State ( 0 ) local gui = New \"ScreenGui\" { Parent = Players . LocalPlayer . PlayerGui , Name = \"CountingGui\" , ZIndexBehavior = \"Sibling\" , [ Children ] = { Ahora, podemos reemplazar el texto provisional con un computed state, para tornar el n\u00famero de clics dentro de un mensaje completo: 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 Text = \"\u00a1Cliqueame!\" }, New \"TextLabel\" { Name = \"Message\" , Position = UDim2 . new ( 0.5 , 0 , 0.5 , 100 ), Size = UDim2 . fromOffset ( 200 , 50 ), AnchorPoint = Vector2 . new ( .5 , .5 ), BackgroundColor3 = Color3 . fromRGB ( 255 , 255 , 255 ), Text = Computed ( function () return \"Cliqueaste \" .. numClicks : get () .. \" veces.\" end ) } } } Ahora te dar\u00e1s cuenta que el mensaje refleja en el texto el n\u00famero de clics guardados en numClicks :","title":"Agregando State"},{"location":"tutorials/fundamentals/project-1/#monitoreando-clics","text":"Ahora que ya tenemos nuestra UI en su lugar y funciona con nuestro state, solo tenemos que incrementar el n\u00famero de clics guardados en numClicks cuando liqueamos el bot\u00f3n. Para comenzar, agreguemos un handler de OnEvent para el evento Activated del bot\u00f3n. Esto se ejecutar\u00e1 cuando cliqueamos el bot\u00f3n. [ Children ] = { New \"TextButton\" { Name = \"ClickButton\" , Position = UDim2 . fromScale ( .5 , .5 ), Size = UDim2 . fromOffset ( 200 , 50 ), AnchorPoint = Vector2 . new ( .5 , .5 ), BackgroundColor3 = Color3 . fromRGB ( 85 , 255 , 0 ), Text = \"\u00a1Cliqueame!\" , [ OnEvent \"Activated\" ] = function () -- \u00a1el bot\u00f3n fue cliqueado! -- TODO: incrementar el state end }, New \"TextLabel\" { Luego, para incrementar el state, podemos usar :get() para conseguir el n\u00famero de clics, sumarle uno, y establecerlo con :set() con el nuevo valor: [ Children ] = { New \"TextButton\" { Name = \"ClickButton\" , Position = UDim2 . fromScale ( .5 , .5 ), Size = UDim2 . fromOffset ( 200 , 50 ), AnchorPoint = Vector2 . new ( .5 , .5 ), BackgroundColor3 = Color3 . fromRGB ( 85 , 255 , 0 ), Text = \"\u00a1Cliqueame!\" , [ OnEvent \"Activated\" ] = function () -- \u00a1el bot\u00f3n fue cliqueado! numClicks : set ( numClicks : get () + 1 ) end }, New \"TextLabel\" { Eso es todo - intenta cliquear el bot\u00f3n, y observa el mensaje cambiar en respuesta: Si has logrado seguir a lo largo del tutorial, felicidades - \u00a1ahora deber\u00edas tener un buen conocimiento en los conceptos fundamentales de Fusion! Con solo estas herramientas, ser\u00e1s capaz de construir casi todo lo que puedas pensar. Sin embargo, Fusion a\u00fan tiene m\u00e1s herramientas disponibles para hacer tu c\u00f3digo m\u00e1s f\u00e1cil y simple de gestionar - cubriremos esto en 'Otros Fundamentos' . \u00daltima Actualizaci\u00f3n de la Localizaci\u00f3n 26/09/2021","title":"Monitoreando Clics"},{"location":"tutorials/fundamentals/storing-state/","text":"Nuestros UIs usan unos cuantos datos - llamados 'state' - para cambiar como aparecen. Aprendamos a guardar estos datos en Fusion. C\u00f3digo necesario 1 2 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Fusion = require ( ReplicatedStorage . Fusion ) \u00bfQu\u00e9 es State? \u00b6 State es (simplificando) las variables que determinan como tu UI se ve en un cierto punto del tiempo. Un simple ejemplo de esto es una barra de vida. Para saber como la barra de vida se ve en cualquier cierto punto del tiempo, necesitamos saber dos cosas: la vida actual a mostrar el m\u00e1ximo de vida del jugador Por lo tanto, estas dos variables son conocidas como el 'state' de la barra de vida. Para mostrar la barra de vida en pantalla, necesitamos usar los valores de estas variables. Guardando State \u00b6 Fusion proporciona algunas herramientas buenas para manipular state y usarlo en nuestro UI; pero para usar esas herramientas necesitamos guardar nuestro state en 'state objects' - objetos simples que guardan un solo valor usando OOP. Para usar state objects, primero tenemos que importar el constructor State : 1 2 3 4 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Fusion = require ( ReplicatedStorage . Fusion ) local State = Fusion . State Ahora, podemos crear un state object llamando al constructor. Si pasas un valor, este ser\u00e1 guardado dentro del state object: 1 2 3 4 5 6 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Fusion = require ( ReplicatedStorage . Fusion ) local State = Fusion . State local message = State ( \"Hola\" ) En cualquier momento puedes obtener el valor actualmente guardado con el m\u00e9todo :get() : Lua 1 2 3 4 5 6 7 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Fusion = require ( ReplicatedStorage . Fusion ) local State = Fusion . State local message = State ( \"Hola\" ) print ( \"El valor es:\" , message : get ()) Output esperado El valor es: Hola Tambi\u00e9n puedes establecer el valor llamando :set() con un nuevo valor: Lua 1 2 3 4 5 6 7 8 9 10 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Fusion = require ( ReplicatedStorage . Fusion ) local State = Fusion . State local message = State ( \"Hola\" ) print ( \"El valor es:\" , message : get ()) message : set ( \"Mundo\" ) print ( \"El nuevo valor es:\" , message : get ()) Output esperado El valor es: Hola El nuevo valor es: Mundo Con eso, deber\u00edas tener una idea b\u00e1sica de state objects - son algo como variables, pero en forma de objeto. Estos objetos posteriormente actuar\u00e1n como 'inputs' hacia otras herramientas de manejo de state en Fusion. C\u00f3digo finalizado 1 2 3 4 5 6 7 8 9 10 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Fusion = require ( ReplicatedStorage . Fusion ) local State = Fusion . State local message = State ( \"Hola\" ) print ( \"El valor es:\" , message : get ()) message : set ( \"Mundo\" ) print ( \"El nuevo valor es:\" , message : get ()) \u00daltima Actualizaci\u00f3n de la Localizaci\u00f3n 26/09/2021","title":"Guardando States"},{"location":"tutorials/fundamentals/storing-state/#que-es-state","text":"State es (simplificando) las variables que determinan como tu UI se ve en un cierto punto del tiempo. Un simple ejemplo de esto es una barra de vida. Para saber como la barra de vida se ve en cualquier cierto punto del tiempo, necesitamos saber dos cosas: la vida actual a mostrar el m\u00e1ximo de vida del jugador Por lo tanto, estas dos variables son conocidas como el 'state' de la barra de vida. Para mostrar la barra de vida en pantalla, necesitamos usar los valores de estas variables.","title":"\u00bfQu\u00e9 es State?"},{"location":"tutorials/fundamentals/storing-state/#guardando-state","text":"Fusion proporciona algunas herramientas buenas para manipular state y usarlo en nuestro UI; pero para usar esas herramientas necesitamos guardar nuestro state en 'state objects' - objetos simples que guardan un solo valor usando OOP. Para usar state objects, primero tenemos que importar el constructor State : 1 2 3 4 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Fusion = require ( ReplicatedStorage . Fusion ) local State = Fusion . State Ahora, podemos crear un state object llamando al constructor. Si pasas un valor, este ser\u00e1 guardado dentro del state object: 1 2 3 4 5 6 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Fusion = require ( ReplicatedStorage . Fusion ) local State = Fusion . State local message = State ( \"Hola\" ) En cualquier momento puedes obtener el valor actualmente guardado con el m\u00e9todo :get() : Lua 1 2 3 4 5 6 7 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Fusion = require ( ReplicatedStorage . Fusion ) local State = Fusion . State local message = State ( \"Hola\" ) print ( \"El valor es:\" , message : get ()) Output esperado El valor es: Hola Tambi\u00e9n puedes establecer el valor llamando :set() con un nuevo valor: Lua 1 2 3 4 5 6 7 8 9 10 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Fusion = require ( ReplicatedStorage . Fusion ) local State = Fusion . State local message = State ( \"Hola\" ) print ( \"El valor es:\" , message : get ()) message : set ( \"Mundo\" ) print ( \"El nuevo valor es:\" , message : get ()) Output esperado El valor es: Hola El nuevo valor es: Mundo Con eso, deber\u00edas tener una idea b\u00e1sica de state objects - son algo como variables, pero en forma de objeto. Estos objetos posteriormente actuar\u00e1n como 'inputs' hacia otras herramientas de manejo de state en Fusion. C\u00f3digo finalizado 1 2 3 4 5 6 7 8 9 10 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Fusion = require ( ReplicatedStorage . Fusion ) local State = Fusion . State local message = State ( \"Hola\" ) print ( \"El valor es:\" , message : get ()) message : set ( \"Mundo\" ) print ( \"El nuevo valor es:\" , message : get ()) \u00daltima Actualizaci\u00f3n de la Localizaci\u00f3n 26/09/2021","title":"Guardando State"},{"location":"tutorials/further-basics/arrays-and-lists/","text":"Trabajar eficientemente con tablas puede ser dif\u00edcil. Aprendamos acerca de las herramientas que Fusion proporciona para que trabajar con arrays y tablas sea m\u00e1s f\u00e1cil. C\u00f3digo necesario 1 2 3 4 5 6 7 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Fusion = require ( ReplicatedStorage . Fusion ) local State = Fusion . State local Computed = Fusion . Computed local numbers = State ({ 1 , 2 , 3 , 4 , 5 }) Computed Arrays \u00b6 Sup\u00f3n que tenemos un state object que guarda una array de n\u00fameros, y queremos crear un computed object el cual duplique cada n\u00famero. Podemos lograr esto usando un loop for-pairs: 7 8 9 10 11 12 13 14 15 16 17 local numbers = State ({ 1 , 2 , 3 , 4 , 5 }) local doubledNumbers = Computed ( function () local doubled = {} for index , number in pairs ( numbers : get ()) do doubled [ index ] = number * 2 end return doubled end ) print ( doubledNumbers : get ()) --> {2, 4, 6, 8, 10} Aunque esto funciona, es muy verboso. Para hacer este c\u00f3digo m\u00e1s simple, Fusion tiene un computed object especial dise\u00f1ado para procesar tablas, conocido como ComputedPairs . Para usarlo, tenemos que importar ComputedPairs desde Fusion: 1 2 3 4 5 6 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Fusion = require ( ReplicatedStorage . Fusion ) local State = Fusion . State local Computed = Fusion . Computed local ComputedPairs = Fusion . ComputedPairs ComputedPairs act\u00faa de manera similar a el loop for-pairs que escribimos arriba - este va por cada entrada de la array, procesa el valor, y lo guarda dentro de la nueva array: 8 9 10 11 12 13 14 local numbers = State ({ 1 , 2 , 3 , 4 , 5 }) local doubledNumbers = ComputedPairs ( numbers , function ( index , number ) return number * 2 end ) print ( doubledNumbers : get ()) --> {2, 4, 6, 8, 10} Esto puede ser usado para procesar cualquier tipo de tabla, no solo arrays. Observa que las keys son las mismas, y el valor es lo que sea que tu regreses: 8 9 10 11 12 13 14 local data = State ({ Blue = \"bueno\" , Green = \"malo\" }) local processedData = ComputedPairs ( data , function ( colour , word ) return colour .. \" es \" .. word end ) print ( processedData : get ()) --> {Blue = \"Blue es bueno\", Green = \"Green es malo\"} Limpiando Valores \u00b6 A veces, podr\u00edas usar ComputedPairs para generar listas de instancias, o otro tipo de datos parecido. Cuando acabemos con estos, necesitamos destruirlos. Convenientemente, ComputedPairs ya limpia algunos tipos cuando son eliminados de la array generada: instancias regresadas ser\u00e1n destruidas conexiones a eventos regresadas ser\u00e1n destruidas funciones regresadas ser\u00e1n ejecutadas objetos regresados tendr\u00e1n sus m\u00e9todos :Destroy() o :destroy() ejecutados -array regresadas tendr\u00e1n su contenido limpio Esto deber\u00eda cubrir la mayor\u00eda de usos por defecto. Sin embargo, si necesitas anular este comportamiento de limpieza, puedes pasar una funci\u00f3n opcional destructor como un segundo argumento. Cuando el valor generado es eliminado o anulado, ser\u00e1 ejecutado para que lo puedas limpiar: Lua 8 9 10 11 12 13 14 15 16 17 18 19 20 local names = State ({ \"John\" , \"Dave\" , \"Sebastian\" }) local greetings = ComputedPairs ( names , function ( index , name ) return \"Hola, \" .. name end , function ( greeting ) print ( \"Eliminado: \" .. greeting ) end ) names : set ({ \"John\" , \"Trey\" , \"Charlie\" }) Output esperado Eliminado: Hola, Dave Eliminado: Hola, Sebastian Optimizaci\u00f3n \u00b6 Para mejorar el rendimiento, ComputedPairs no recalcula una key si su valor sigue igual: Lua 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 local data = State ({ One = 1 , Two = 2 , Three = 3 }) print ( \"Creando processedData...\" ) local processedData = ComputedPairs ( data , function ( key , value ) print ( \" ...recalculando key: \" .. key ) return value * 2 end ) print ( \"Cambiando los valores de algunas keys...\" ) data : set ({ One = 1 , Two = 100 , Three = 3 , Four = 4 }) Output esperado Creando processedData... ...recalculando key: One ...recalculando key: Two ...recalculando key: Three Cambiando los valores de algunas keys... ...recalculando key: Two ...recalculando key: Four Debido a que las keys Two y Four tienen diferentes valores despu\u00e9s del cambio, son recalculadas. Sin embargo, One y Three tienen los mismos valores, as\u00ed que se reutilizar\u00e1n en su lugar: Esto es una simple regla que deber\u00eda funcionar adecuadamente para las tablas con 'stable keys' (keys que no cambian cuando otros valores son agregados o eliminados). Sin embargo, si est\u00e1s trabajando con 'keys inestables' (ej. una array en la cual los valores se pueden mover a diferentes keys) puedes obtener rec\u00e1lculos innecesarios. En el siguiente c\u00f3digo, Yellow es recalculado, porque se mueve a una key diferente: Lua 8 9 10 11 12 13 14 15 16 17 18 local data = State ({ \"Red\" , \"Green\" , \"Blue\" , \"Yellow\" }) print ( \"Creando processedData...\" ) local processedData = ComputedPairs ( data , function ( key , value ) print ( \" ...recalculando key: \" .. key .. \" valor: \" .. value ) return value end ) print ( \"Eliminando Blue...\" ) data : set ({ \"Red\" , \"Green\" , \"Yellow\" }) Output esperado Creando processedData... ...recalculando key: 1 valor: Red ...recalculando key: 2 valor: Green ...recalculando key: 3 valor: Blue ...recalculando key: 4 valor: Yellow Moving the values around... ...recalculando key: 3 valor: Yellow Puedes ver esto m\u00e1s claramente en el siguiente diagrama - el valor de la key 3 ha cambiado, as\u00ed que provoc\u00f3 una recalculaci\u00f3n: Si las keys no se necesitan, puedes usar tus valores como keys. Esto las hace estables, ya que no ser\u00e1n afectadas por otras inserciones o extracciones: Lua 8 9 10 11 12 13 14 15 16 17 18 local data = State ({ Red = true , Green = true , Blue = true , Yellow = true }) print ( \"Creando processedData...\" ) local processedData = ComputedPairs ( data , function ( key ) print ( \" ...recalculando key: \" .. key ) return key end ) print ( \"Eliminando Blue...\" ) data : set ({ Red = true , Green = true , Yellow = true }) Output esperado Creando processedData... ...recalculando key: Red ...recalculando key: Green ...recalculando key: Blue ...recalculando key: Yellow Eliminando Blue... Fijate que, cuando eliminamos Blue , ning\u00fan otro valor es recalculado. Esto es ideal, y significa que no estamos haciendo procesos innecesarios: Esto es especialmente importante al optimizar arrays \u2018pesadas\u2019, por ejemplo largas listas de instancias. \u00a1Entre menos rec\u00e1lculo innecesario, mejor! Con esto, deber\u00edas tener una idea b\u00e1sica de como trabajar con state de tablas en Fusion. Cuando te acostumbres a este flujo de trabajo, puedes expresar tu l\u00f3gica h\u00e1bilmente, y tener un buen comportamiento de almacenamiento de cach\u00e9 y limpieza gratuitamente. C\u00f3digo finalizado 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Fusion = require ( ReplicatedStorage . Fusion ) local State = Fusion . State local Computed = Fusion . Computed local ComputedPairs = Fusion . ComputedPairs local data = State ({ Red = true , Green = true , Blue = true , Yellow = true }) print ( \"Creando processedData...\" ) local processedData = ComputedPairs ( data , function ( key ) print ( \" ...recalculando key: \" .. key ) return key end ) print ( \"Eliminando Blue...\" ) data : set ({ Red = true , Green = true , Yellow = true }) \u00daltima Actualizaci\u00f3n de la Localizaci\u00f3n 10/10/2021","title":"Arrays y Listas"},{"location":"tutorials/further-basics/arrays-and-lists/#computed-arrays","text":"Sup\u00f3n que tenemos un state object que guarda una array de n\u00fameros, y queremos crear un computed object el cual duplique cada n\u00famero. Podemos lograr esto usando un loop for-pairs: 7 8 9 10 11 12 13 14 15 16 17 local numbers = State ({ 1 , 2 , 3 , 4 , 5 }) local doubledNumbers = Computed ( function () local doubled = {} for index , number in pairs ( numbers : get ()) do doubled [ index ] = number * 2 end return doubled end ) print ( doubledNumbers : get ()) --> {2, 4, 6, 8, 10} Aunque esto funciona, es muy verboso. Para hacer este c\u00f3digo m\u00e1s simple, Fusion tiene un computed object especial dise\u00f1ado para procesar tablas, conocido como ComputedPairs . Para usarlo, tenemos que importar ComputedPairs desde Fusion: 1 2 3 4 5 6 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Fusion = require ( ReplicatedStorage . Fusion ) local State = Fusion . State local Computed = Fusion . Computed local ComputedPairs = Fusion . ComputedPairs ComputedPairs act\u00faa de manera similar a el loop for-pairs que escribimos arriba - este va por cada entrada de la array, procesa el valor, y lo guarda dentro de la nueva array: 8 9 10 11 12 13 14 local numbers = State ({ 1 , 2 , 3 , 4 , 5 }) local doubledNumbers = ComputedPairs ( numbers , function ( index , number ) return number * 2 end ) print ( doubledNumbers : get ()) --> {2, 4, 6, 8, 10} Esto puede ser usado para procesar cualquier tipo de tabla, no solo arrays. Observa que las keys son las mismas, y el valor es lo que sea que tu regreses: 8 9 10 11 12 13 14 local data = State ({ Blue = \"bueno\" , Green = \"malo\" }) local processedData = ComputedPairs ( data , function ( colour , word ) return colour .. \" es \" .. word end ) print ( processedData : get ()) --> {Blue = \"Blue es bueno\", Green = \"Green es malo\"}","title":"Computed Arrays"},{"location":"tutorials/further-basics/arrays-and-lists/#limpiando-valores","text":"A veces, podr\u00edas usar ComputedPairs para generar listas de instancias, o otro tipo de datos parecido. Cuando acabemos con estos, necesitamos destruirlos. Convenientemente, ComputedPairs ya limpia algunos tipos cuando son eliminados de la array generada: instancias regresadas ser\u00e1n destruidas conexiones a eventos regresadas ser\u00e1n destruidas funciones regresadas ser\u00e1n ejecutadas objetos regresados tendr\u00e1n sus m\u00e9todos :Destroy() o :destroy() ejecutados -array regresadas tendr\u00e1n su contenido limpio Esto deber\u00eda cubrir la mayor\u00eda de usos por defecto. Sin embargo, si necesitas anular este comportamiento de limpieza, puedes pasar una funci\u00f3n opcional destructor como un segundo argumento. Cuando el valor generado es eliminado o anulado, ser\u00e1 ejecutado para que lo puedas limpiar: Lua 8 9 10 11 12 13 14 15 16 17 18 19 20 local names = State ({ \"John\" , \"Dave\" , \"Sebastian\" }) local greetings = ComputedPairs ( names , function ( index , name ) return \"Hola, \" .. name end , function ( greeting ) print ( \"Eliminado: \" .. greeting ) end ) names : set ({ \"John\" , \"Trey\" , \"Charlie\" }) Output esperado Eliminado: Hola, Dave Eliminado: Hola, Sebastian","title":"Limpiando Valores"},{"location":"tutorials/further-basics/arrays-and-lists/#optimizacion","text":"Para mejorar el rendimiento, ComputedPairs no recalcula una key si su valor sigue igual: Lua 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 local data = State ({ One = 1 , Two = 2 , Three = 3 }) print ( \"Creando processedData...\" ) local processedData = ComputedPairs ( data , function ( key , value ) print ( \" ...recalculando key: \" .. key ) return value * 2 end ) print ( \"Cambiando los valores de algunas keys...\" ) data : set ({ One = 1 , Two = 100 , Three = 3 , Four = 4 }) Output esperado Creando processedData... ...recalculando key: One ...recalculando key: Two ...recalculando key: Three Cambiando los valores de algunas keys... ...recalculando key: Two ...recalculando key: Four Debido a que las keys Two y Four tienen diferentes valores despu\u00e9s del cambio, son recalculadas. Sin embargo, One y Three tienen los mismos valores, as\u00ed que se reutilizar\u00e1n en su lugar: Esto es una simple regla que deber\u00eda funcionar adecuadamente para las tablas con 'stable keys' (keys que no cambian cuando otros valores son agregados o eliminados). Sin embargo, si est\u00e1s trabajando con 'keys inestables' (ej. una array en la cual los valores se pueden mover a diferentes keys) puedes obtener rec\u00e1lculos innecesarios. En el siguiente c\u00f3digo, Yellow es recalculado, porque se mueve a una key diferente: Lua 8 9 10 11 12 13 14 15 16 17 18 local data = State ({ \"Red\" , \"Green\" , \"Blue\" , \"Yellow\" }) print ( \"Creando processedData...\" ) local processedData = ComputedPairs ( data , function ( key , value ) print ( \" ...recalculando key: \" .. key .. \" valor: \" .. value ) return value end ) print ( \"Eliminando Blue...\" ) data : set ({ \"Red\" , \"Green\" , \"Yellow\" }) Output esperado Creando processedData... ...recalculando key: 1 valor: Red ...recalculando key: 2 valor: Green ...recalculando key: 3 valor: Blue ...recalculando key: 4 valor: Yellow Moving the values around... ...recalculando key: 3 valor: Yellow Puedes ver esto m\u00e1s claramente en el siguiente diagrama - el valor de la key 3 ha cambiado, as\u00ed que provoc\u00f3 una recalculaci\u00f3n: Si las keys no se necesitan, puedes usar tus valores como keys. Esto las hace estables, ya que no ser\u00e1n afectadas por otras inserciones o extracciones: Lua 8 9 10 11 12 13 14 15 16 17 18 local data = State ({ Red = true , Green = true , Blue = true , Yellow = true }) print ( \"Creando processedData...\" ) local processedData = ComputedPairs ( data , function ( key ) print ( \" ...recalculando key: \" .. key ) return key end ) print ( \"Eliminando Blue...\" ) data : set ({ Red = true , Green = true , Yellow = true }) Output esperado Creando processedData... ...recalculando key: Red ...recalculando key: Green ...recalculando key: Blue ...recalculando key: Yellow Eliminando Blue... Fijate que, cuando eliminamos Blue , ning\u00fan otro valor es recalculado. Esto es ideal, y significa que no estamos haciendo procesos innecesarios: Esto es especialmente importante al optimizar arrays \u2018pesadas\u2019, por ejemplo largas listas de instancias. \u00a1Entre menos rec\u00e1lculo innecesario, mejor! Con esto, deber\u00edas tener una idea b\u00e1sica de como trabajar con state de tablas en Fusion. Cuando te acostumbres a este flujo de trabajo, puedes expresar tu l\u00f3gica h\u00e1bilmente, y tener un buen comportamiento de almacenamiento de cach\u00e9 y limpieza gratuitamente. C\u00f3digo finalizado 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Fusion = require ( ReplicatedStorage . Fusion ) local State = Fusion . State local Computed = Fusion . Computed local ComputedPairs = Fusion . ComputedPairs local data = State ({ Red = true , Green = true , Blue = true , Yellow = true }) print ( \"Creando processedData...\" ) local processedData = ComputedPairs ( data , function ( key ) print ( \" ...recalculando key: \" .. key ) return key end ) print ( \"Eliminando Blue...\" ) data : set ({ Red = true , Green = true , Yellow = true }) \u00daltima Actualizaci\u00f3n de la Localizaci\u00f3n 10/10/2021","title":"Optimizaci\u00f3n"},{"location":"tutorials/further-basics/compatibility/","text":"En construcci\u00f3n Esta p\u00e1gina est\u00e1 en construcci\u00f3n - la informaci\u00f3n puede faltar o estar incompleta. \u00daltima Actualizaci\u00f3n de la Localizaci\u00f3n 25/09/2021","title":"Compatibilidad"},{"location":"tutorials/further-basics/components/","text":"Usualmente es una buena idea separar nuestra UI en partes reutilizables, conocidas como 'componentes'. Aprendamos c\u00f3mo crearlas con Fusion. \u00bfQu\u00e9 son los Componentes? \u00b6 Cuando pensamos en UIs como humanos, usualmente las pensamos en t\u00e9rminos de \u2018bloques\u2019 reutilizables de UI. Por ejemplo, puedes dividir la siguiente interfaz en estos \u2018bloques\u2019. En el dise\u00f1o y desarrollo de UI, estos son ampliamente conocidos como \u2018componentes\u2019. Los componentes son \u00fatiles, porque solo necesitamos definir como cada uno se ve en general . Luego podemos aplicar esa apariencia a cada componente a lo largo de nuestra UI. Puedes incluso proporcionar propiedades, como texto a insertar, o si se muestra un icono: Construyendo nuestra UI ensamblando componentes (en vez de crear cada instancia manualmente) nos ayudar\u00e1 a reutilizar y organizar nuestro c\u00f3digo de UI, y lo hace m\u00e1s f\u00e1cil de leer y editar. Reutilizando UI \u00b6 Cuando queremos reutilizar algo de c\u00f3digo, usualmente lo ponemos en una funci\u00f3n. Despu\u00e9s podemos usar ese fragmento de c\u00f3digo en m\u00faltiples lugares, opcionalmente proporcionando argumentos para ajustar c\u00f3mo se ejecuta. Eso se alinea con lo que necesitamos que los \u2018componentes\u2019 hagan - queremos que sea posible reutilizar partes de nuestra UI en m\u00faltiples lugares, opcionalmente proporcionando propiedades para ajustar c\u00f3mo se ve. Por esto, en Fusion, los componentes son solo funciones. Toman una tabla de propiedades, crean UI, y la regresan: local function Greeting ( props ) return New \"TextLabel\" { BackgroundColor3 = Color3 . new ( 1 , 1 , 0 ), TextColor3 = Color3 . new ( 0 , 0 , 1 ), Size = UDim2 . fromOffset ( 200 , 50 ), Text = props . Message } end Podemos llamar la funci\u00f3n Greeting para obtener una copia de esa UI con cualquier mensaje que deseemos: local greeting1 = Greeting { Message = \"\u00a1Hola!\" } local greeting2 = Greeting { Message = \"Ey :)\" } Note Si est\u00e1s usando un solo argumento props (como lo hicimos anteriormente), \u00a1no necesitas par\u00e9ntesis () al llamar la funci\u00f3n con una tabla! Tambi\u00e9n podemos incorporar componentes dentro de otro c\u00f3digo de Fusion facilmente: local gui = New \"ScreenGui\" { Name = \"ExampleGui\" , ZIndexBehavior = \"Sibling\" , [ Children ] = Greeting { Message = \"\u00bfQu\u00e9 pasa? B)\" } } Esto hace a los componentes una herramienta potente para crear c\u00f3digo de UI organizado y reutilizable dentro de Fusion. Por el resto del tutorial, veamos patrones de programaci\u00f3n comunes que puedes usar con componentes para hacerlos a\u00fan m\u00e1s \u00fatiles. Pasando Children \u00b6 A veces, deseamos crear componentes que pueden tener children. Por ejemplo, veamos este componente que ordena children dentro de un scrolling grid: local function Gallery ( props ) return New \"ScrollingFrame\" { Position = props . Position , Size = props . Size , AnchorPoint = props . AnchorPoint , [ Children ] = { New \"UIGridLayout\" { CellPadding = UDim2 . fromOffset ( 4 , 4 ), CellSize = UDim2 . fromOffset ( 100 , 100 ) }, -- TODO: \u00bfagregar algunos children aqu\u00ed? } } end Supongamos que queremos que los usuarios pasen children para que aparezcan en el grid: local gallery = Gallery { Position = UDim2 . fromScale ( .5 , .5 ) Size = UDim2 . fromOffset ( 400 , 300 ), AnchorPoint = Vector2 . new ( .5 , .5 ), [ Children ] = { New \"ImageLabel\" { ... }, New \"ImageLabel\" { ... }, New \"ImageLabel\" { ... } } } Podemos acceder a estos children en nuestra funci\u00f3n usando props [ Children ] .Ya que la funci\u00f3n New nos permite pasar arrays de children, podemos incluirlas directamente en nuestro c\u00f3digo as\u00ed: local function Gallery ( props ) return New \"ScrollingFrame\" { Position = props . Position , Size = props . Size , AnchorPoint = props . AnchorPoint , [ Children ] = { New \"UIGridLayout\" { CellPadding = UDim2 . fromOffset ( 4 , 4 ), CellSize = UDim2 . fromOffset ( 100 , 100 ) }, props [ Children ] } } end \u00a1Eso es todo lo que hay! Solo recuerda que [ Children ] a\u00fan es una propiedad como cualquiera, as\u00ed que si est\u00e1s procesando los children, puede ser bueno primero hacer una comprobaci\u00f3n de tipos: M\u00faltiples Instancias \u00b6 En algunas circunstancias espec\u00edficas, podr\u00edas desear regresar m\u00e1s de una instancia de un componente. No debes regresar m\u00faltiples valores de un componente directamente. Debido a como Lua funciona, esto puede producir bugs sutiles en tu c\u00f3digo: local function ManyThings ( props ) -- \u00a1no hagas esto! -- debes regresar un solo valor de un componente return New \"TextLabel\" {...}, New \"ImageButton\" {...}, New \"Frame\" {...} end local gui1 = New \"ScreenGui\" { -- \u00a1esto solo establecer\u00e1 el parent del TextLabel! [ Children ] = ManyThings {} } local gui2 = New \"ScreenGui\" { [ Children ] = { New \"TextLabel\" {...}, -- esto tampoco funciona ManyThings {}, New \"TextLabel\" {...} } } Una mejor manera de hacer esto es regresar una array de instancias. Esto significa que regresas un solo valor - la array. Esto evita los bugs sutiles que usualmente ocurren al lidiar con m\u00faltiples valores regresados. Ya que [ Children ] permite arrays de children, todos los parents de nuestras instancias fueron establecidos como lo esperado: local function ManyThings ( props ) -- usar una array se asegura de que solo regresamos un valor return { New \"TextLabel\" {...}, New \"ImageButton\" {...}, New \"Frame\" {...} } end local gui1 = New \"ScreenGui\" { -- \u00a1ahora esto funciona! [ Children ] = ManyThings {} } local gui2 = New \"ScreenGui\" { [ Children ] = { New \"TextLabel\" {...}, -- \u00a1esto tambi\u00e9n funciona ahora! ManyThings {}, New \"TextLabel\" {...} } } Tip Si vienes de otras bibliotecas de UI o frameworks, podr\u00edas haber escuchado de este concepto referido como 'fragmentos'. En Fusion, los fragmentos son solo plain arrays de children en vez de alg\u00fan tipo de objeto especial. Callbacks \u00b6 Para algunos componentes (ej. botones o text boxes), es posible que alg\u00fan c\u00f3digo deba ejecutarse en respuesta a eventos como clics o escritura. Puedes usar callbacks para lograr esto. Considera este componente Button como un ejemplo. F\u00edjate que ahora usamos props.OnClick con [ OnEvent \"Activated\" ] : local function Button ( props ) return New \"TextButton\" { Position = props . Position , AnchorPoint = props . AnchorPoint , Size = props . Size , BackgroundColor3 = Color3 . new ( 0 , 0.4 , 1 ), TextColor3 = Color3 . new ( 1 , 1 , 1 ), Text = props . Message , [ OnEvent \"Activated\" ] = props . OnClick } end Esto significa que cualquiera que use el componente Button puede proporcionar una funci\u00f3n callback, la cual ser\u00e1 ejecutada cuando el bot\u00f3n sea presionado: local gui = New \"ScreenGui\" { Name = \"ExampleGui\" , ZIndexBehavior = \"Sibling\" , [ Children ] = { Button { Position = UDim2 . fromScale ( .5 , .5 ), AnchorPoint = Vector2 . new ( .5 , .5 ), Size = UDim2 . fromOffset ( 200 , 50 ), Message = \"\u00a1Cliqueame!\" , OnClick = function () -- esta funci\u00f3n callback ser\u00e1 pasada dentro de OnEvent, -- y se ejecutar\u00e1 cuando el bot\u00f3n sea presionado print ( \"\u00a1El bot\u00f3n fue cliqueado!\" ) end }, } } Esto no est\u00e1 limitado a controladores de evento, en cualquier momento que desees permitir al caller proporcionar c\u00f3digo, los callbacks son una buena opci\u00f3n. State \u00b6 Debido a que los componentes son funciones, podemos hacer m\u00e1s que solo crear instancias. \u00a1Tambi\u00e9n puedes guardar state dentro de estos! Crearemos un componente de 'toggle button' para demostrar esto. Cuando lo presionamos, deber\u00eda alternarse entre on y off. Aqu\u00ed hay c\u00f3digo b\u00e1sico para empezar - s\u00f3lo necesitamos agregarle un state a esto: local function ToggleButton ( props ) return New \"TextButton\" { BackgroundColor3 = Color3 . new ( 1 , 1 , 1 ), TextColor3 = Color3 . new ( 0 , 0 , 0 ), Size = UDim2 . fromOffset ( 200 , 50 ), Text = props . message , [ OnEvent \"Activated\" ] = function () -- TODO: \u00a1alternar el bot\u00f3n! end } end Primero, crearemos un state object para guardar en que estado est\u00e1 el bot\u00f3n, on o off: local function ToggleButton ( props ) local isButtonOn = State ( false ) return New \"TextButton\" { BackgroundColor3 = Color3 . new ( 1 , 1 , 1 ), TextColor3 = Color3 . new ( 0 , 0 , 0 ), Text = props . message , [ OnEvent \"Activated\" ] = function () -- TODO: \u00a1alternar el bot\u00f3n! end } end Despu\u00e9s, podemos alternar el valor guardado en nuestro controlador de eventos: local function ToggleButton ( props ) local isButtonOn = State ( false ) return New \"TextButton\" { BackgroundColor3 = Color3 . new ( 1 , 1 , 1 ), TextColor3 = Color3 . new ( 0 , 0 , 0 ), Text = props . message , [ OnEvent \"Activated\" ] = function () isButtonOn : set ( not isButtonOn : get ()) end } end Por \u00faltimo, podemos hacer que el color del fondo muestre si el bot\u00f3n est\u00e1 alternado en on o off, usando un computed state: local function ToggleButton ( props ) local isButtonOn = State ( false ) return New \"TextButton\" { BackgroundColor3 = Computed ( function () if isButtonOn : get () then return Color3 . new ( 0 , 1 , 0 ) -- verde cuando est\u00e1 en on else return Color3 . new ( 1 , 0 , 0 ) -- rojo cuando est\u00e1 en off end end ), TextColor3 = Color3 . new ( 0 , 0 , 0 ), Text = props . message , [ OnEvent \"Activated\" ] = function () isButtonOn : set ( not isButtonOn : get ()) end } end \u00a1Con solo este c\u00f3digo hicimos que nuestro bot\u00f3n sea completamente funcional! De nuevo, esta es una funci\u00f3n normal de Lua, as\u00ed que no est\u00e1 pasando nada sofisticado tras bambalinas. Tal como antes, ahora podemos incluir nuestro bot\u00f3n en nuestra UI f\u00e1cilmente: local gui = New \"ScreenGui\" { Name = \"ExampleGui\" , ZIndexBehavior = \"Sibling\" , [ Children ] = { New \"UIListLayout\" { Padding = UDim . new ( 0 , 4 ) }, ToggleButton { message = \"\u00a1Cliqueame!\" }, ToggleButton { message = \"Tambi\u00e9n, \u00a1cliqueame!\" }, ToggleButton { message = \"Cada bot\u00f3n es independiente :)\" } } } Ya que creamos un nuevo bot\u00f3n cada vez que llamamos la funci\u00f3n, cada bot\u00f3n guarda su propio state y funciones de manera independiente. \u00daltima Actualizaci\u00f3n de la Localizaci\u00f3n 10/10/2021","title":"Componentes"},{"location":"tutorials/further-basics/components/#que-son-los-componentes","text":"Cuando pensamos en UIs como humanos, usualmente las pensamos en t\u00e9rminos de \u2018bloques\u2019 reutilizables de UI. Por ejemplo, puedes dividir la siguiente interfaz en estos \u2018bloques\u2019. En el dise\u00f1o y desarrollo de UI, estos son ampliamente conocidos como \u2018componentes\u2019. Los componentes son \u00fatiles, porque solo necesitamos definir como cada uno se ve en general . Luego podemos aplicar esa apariencia a cada componente a lo largo de nuestra UI. Puedes incluso proporcionar propiedades, como texto a insertar, o si se muestra un icono: Construyendo nuestra UI ensamblando componentes (en vez de crear cada instancia manualmente) nos ayudar\u00e1 a reutilizar y organizar nuestro c\u00f3digo de UI, y lo hace m\u00e1s f\u00e1cil de leer y editar.","title":"\u00bfQu\u00e9 son los Componentes?"},{"location":"tutorials/further-basics/components/#reutilizando-ui","text":"Cuando queremos reutilizar algo de c\u00f3digo, usualmente lo ponemos en una funci\u00f3n. Despu\u00e9s podemos usar ese fragmento de c\u00f3digo en m\u00faltiples lugares, opcionalmente proporcionando argumentos para ajustar c\u00f3mo se ejecuta. Eso se alinea con lo que necesitamos que los \u2018componentes\u2019 hagan - queremos que sea posible reutilizar partes de nuestra UI en m\u00faltiples lugares, opcionalmente proporcionando propiedades para ajustar c\u00f3mo se ve. Por esto, en Fusion, los componentes son solo funciones. Toman una tabla de propiedades, crean UI, y la regresan: local function Greeting ( props ) return New \"TextLabel\" { BackgroundColor3 = Color3 . new ( 1 , 1 , 0 ), TextColor3 = Color3 . new ( 0 , 0 , 1 ), Size = UDim2 . fromOffset ( 200 , 50 ), Text = props . Message } end Podemos llamar la funci\u00f3n Greeting para obtener una copia de esa UI con cualquier mensaje que deseemos: local greeting1 = Greeting { Message = \"\u00a1Hola!\" } local greeting2 = Greeting { Message = \"Ey :)\" } Note Si est\u00e1s usando un solo argumento props (como lo hicimos anteriormente), \u00a1no necesitas par\u00e9ntesis () al llamar la funci\u00f3n con una tabla! Tambi\u00e9n podemos incorporar componentes dentro de otro c\u00f3digo de Fusion facilmente: local gui = New \"ScreenGui\" { Name = \"ExampleGui\" , ZIndexBehavior = \"Sibling\" , [ Children ] = Greeting { Message = \"\u00bfQu\u00e9 pasa? B)\" } } Esto hace a los componentes una herramienta potente para crear c\u00f3digo de UI organizado y reutilizable dentro de Fusion. Por el resto del tutorial, veamos patrones de programaci\u00f3n comunes que puedes usar con componentes para hacerlos a\u00fan m\u00e1s \u00fatiles.","title":"Reutilizando UI"},{"location":"tutorials/further-basics/components/#pasando-children","text":"A veces, deseamos crear componentes que pueden tener children. Por ejemplo, veamos este componente que ordena children dentro de un scrolling grid: local function Gallery ( props ) return New \"ScrollingFrame\" { Position = props . Position , Size = props . Size , AnchorPoint = props . AnchorPoint , [ Children ] = { New \"UIGridLayout\" { CellPadding = UDim2 . fromOffset ( 4 , 4 ), CellSize = UDim2 . fromOffset ( 100 , 100 ) }, -- TODO: \u00bfagregar algunos children aqu\u00ed? } } end Supongamos que queremos que los usuarios pasen children para que aparezcan en el grid: local gallery = Gallery { Position = UDim2 . fromScale ( .5 , .5 ) Size = UDim2 . fromOffset ( 400 , 300 ), AnchorPoint = Vector2 . new ( .5 , .5 ), [ Children ] = { New \"ImageLabel\" { ... }, New \"ImageLabel\" { ... }, New \"ImageLabel\" { ... } } } Podemos acceder a estos children en nuestra funci\u00f3n usando props [ Children ] .Ya que la funci\u00f3n New nos permite pasar arrays de children, podemos incluirlas directamente en nuestro c\u00f3digo as\u00ed: local function Gallery ( props ) return New \"ScrollingFrame\" { Position = props . Position , Size = props . Size , AnchorPoint = props . AnchorPoint , [ Children ] = { New \"UIGridLayout\" { CellPadding = UDim2 . fromOffset ( 4 , 4 ), CellSize = UDim2 . fromOffset ( 100 , 100 ) }, props [ Children ] } } end \u00a1Eso es todo lo que hay! Solo recuerda que [ Children ] a\u00fan es una propiedad como cualquiera, as\u00ed que si est\u00e1s procesando los children, puede ser bueno primero hacer una comprobaci\u00f3n de tipos:","title":"Pasando Children"},{"location":"tutorials/further-basics/components/#multiples-instancias","text":"En algunas circunstancias espec\u00edficas, podr\u00edas desear regresar m\u00e1s de una instancia de un componente. No debes regresar m\u00faltiples valores de un componente directamente. Debido a como Lua funciona, esto puede producir bugs sutiles en tu c\u00f3digo: local function ManyThings ( props ) -- \u00a1no hagas esto! -- debes regresar un solo valor de un componente return New \"TextLabel\" {...}, New \"ImageButton\" {...}, New \"Frame\" {...} end local gui1 = New \"ScreenGui\" { -- \u00a1esto solo establecer\u00e1 el parent del TextLabel! [ Children ] = ManyThings {} } local gui2 = New \"ScreenGui\" { [ Children ] = { New \"TextLabel\" {...}, -- esto tampoco funciona ManyThings {}, New \"TextLabel\" {...} } } Una mejor manera de hacer esto es regresar una array de instancias. Esto significa que regresas un solo valor - la array. Esto evita los bugs sutiles que usualmente ocurren al lidiar con m\u00faltiples valores regresados. Ya que [ Children ] permite arrays de children, todos los parents de nuestras instancias fueron establecidos como lo esperado: local function ManyThings ( props ) -- usar una array se asegura de que solo regresamos un valor return { New \"TextLabel\" {...}, New \"ImageButton\" {...}, New \"Frame\" {...} } end local gui1 = New \"ScreenGui\" { -- \u00a1ahora esto funciona! [ Children ] = ManyThings {} } local gui2 = New \"ScreenGui\" { [ Children ] = { New \"TextLabel\" {...}, -- \u00a1esto tambi\u00e9n funciona ahora! ManyThings {}, New \"TextLabel\" {...} } } Tip Si vienes de otras bibliotecas de UI o frameworks, podr\u00edas haber escuchado de este concepto referido como 'fragmentos'. En Fusion, los fragmentos son solo plain arrays de children en vez de alg\u00fan tipo de objeto especial.","title":"M\u00faltiples Instancias"},{"location":"tutorials/further-basics/components/#callbacks","text":"Para algunos componentes (ej. botones o text boxes), es posible que alg\u00fan c\u00f3digo deba ejecutarse en respuesta a eventos como clics o escritura. Puedes usar callbacks para lograr esto. Considera este componente Button como un ejemplo. F\u00edjate que ahora usamos props.OnClick con [ OnEvent \"Activated\" ] : local function Button ( props ) return New \"TextButton\" { Position = props . Position , AnchorPoint = props . AnchorPoint , Size = props . Size , BackgroundColor3 = Color3 . new ( 0 , 0.4 , 1 ), TextColor3 = Color3 . new ( 1 , 1 , 1 ), Text = props . Message , [ OnEvent \"Activated\" ] = props . OnClick } end Esto significa que cualquiera que use el componente Button puede proporcionar una funci\u00f3n callback, la cual ser\u00e1 ejecutada cuando el bot\u00f3n sea presionado: local gui = New \"ScreenGui\" { Name = \"ExampleGui\" , ZIndexBehavior = \"Sibling\" , [ Children ] = { Button { Position = UDim2 . fromScale ( .5 , .5 ), AnchorPoint = Vector2 . new ( .5 , .5 ), Size = UDim2 . fromOffset ( 200 , 50 ), Message = \"\u00a1Cliqueame!\" , OnClick = function () -- esta funci\u00f3n callback ser\u00e1 pasada dentro de OnEvent, -- y se ejecutar\u00e1 cuando el bot\u00f3n sea presionado print ( \"\u00a1El bot\u00f3n fue cliqueado!\" ) end }, } } Esto no est\u00e1 limitado a controladores de evento, en cualquier momento que desees permitir al caller proporcionar c\u00f3digo, los callbacks son una buena opci\u00f3n.","title":"Callbacks"},{"location":"tutorials/further-basics/components/#state","text":"Debido a que los componentes son funciones, podemos hacer m\u00e1s que solo crear instancias. \u00a1Tambi\u00e9n puedes guardar state dentro de estos! Crearemos un componente de 'toggle button' para demostrar esto. Cuando lo presionamos, deber\u00eda alternarse entre on y off. Aqu\u00ed hay c\u00f3digo b\u00e1sico para empezar - s\u00f3lo necesitamos agregarle un state a esto: local function ToggleButton ( props ) return New \"TextButton\" { BackgroundColor3 = Color3 . new ( 1 , 1 , 1 ), TextColor3 = Color3 . new ( 0 , 0 , 0 ), Size = UDim2 . fromOffset ( 200 , 50 ), Text = props . message , [ OnEvent \"Activated\" ] = function () -- TODO: \u00a1alternar el bot\u00f3n! end } end Primero, crearemos un state object para guardar en que estado est\u00e1 el bot\u00f3n, on o off: local function ToggleButton ( props ) local isButtonOn = State ( false ) return New \"TextButton\" { BackgroundColor3 = Color3 . new ( 1 , 1 , 1 ), TextColor3 = Color3 . new ( 0 , 0 , 0 ), Text = props . message , [ OnEvent \"Activated\" ] = function () -- TODO: \u00a1alternar el bot\u00f3n! end } end Despu\u00e9s, podemos alternar el valor guardado en nuestro controlador de eventos: local function ToggleButton ( props ) local isButtonOn = State ( false ) return New \"TextButton\" { BackgroundColor3 = Color3 . new ( 1 , 1 , 1 ), TextColor3 = Color3 . new ( 0 , 0 , 0 ), Text = props . message , [ OnEvent \"Activated\" ] = function () isButtonOn : set ( not isButtonOn : get ()) end } end Por \u00faltimo, podemos hacer que el color del fondo muestre si el bot\u00f3n est\u00e1 alternado en on o off, usando un computed state: local function ToggleButton ( props ) local isButtonOn = State ( false ) return New \"TextButton\" { BackgroundColor3 = Computed ( function () if isButtonOn : get () then return Color3 . new ( 0 , 1 , 0 ) -- verde cuando est\u00e1 en on else return Color3 . new ( 1 , 0 , 0 ) -- rojo cuando est\u00e1 en off end end ), TextColor3 = Color3 . new ( 0 , 0 , 0 ), Text = props . message , [ OnEvent \"Activated\" ] = function () isButtonOn : set ( not isButtonOn : get ()) end } end \u00a1Con solo este c\u00f3digo hicimos que nuestro bot\u00f3n sea completamente funcional! De nuevo, esta es una funci\u00f3n normal de Lua, as\u00ed que no est\u00e1 pasando nada sofisticado tras bambalinas. Tal como antes, ahora podemos incluir nuestro bot\u00f3n en nuestra UI f\u00e1cilmente: local gui = New \"ScreenGui\" { Name = \"ExampleGui\" , ZIndexBehavior = \"Sibling\" , [ Children ] = { New \"UIListLayout\" { Padding = UDim . new ( 0 , 4 ) }, ToggleButton { message = \"\u00a1Cliqueame!\" }, ToggleButton { message = \"Tambi\u00e9n, \u00a1cliqueame!\" }, ToggleButton { message = \"Cada bot\u00f3n es independiente :)\" } } } Ya que creamos un nuevo bot\u00f3n cada vez que llamamos la funci\u00f3n, cada bot\u00f3n guarda su propio state y funciones de manera independiente. \u00daltima Actualizaci\u00f3n de la Localizaci\u00f3n 10/10/2021","title":"State"},{"location":"tutorials/further-basics/project-2/","text":"En construcci\u00f3n Esta p\u00e1gina est\u00e1 en construcci\u00f3n - la informaci\u00f3n puede faltar o estar incompleta. \u00daltima Actualizaci\u00f3n de la Localizaci\u00f3n 25/09/2021","title":"Proyecto 2: Lista To-Do"}]}